<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div id="main"><h1><span class="namespace"/>  library module </h1><div id="variables"><h3>Variables</h3></div><div id="functions"><h3>Functions</h3></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq"> xquery version "1.0" encoding "UTF-8";&#xD;
 module namespace xproc = "http://xproc.net/xproc";&#xD;
 (: -------------------------------------------------------------------------------------&#xD;
&#xD;
    xproc.xqm - core xqm containing entry points, primary eval-step function and&#xD;
    control functions.&#xD;
&#xD;
 ---------------------------------------------------------------------------------------- :)&#xD;
&#xD;
 (: XProc Namespace Declaration :)&#xD;
 declare namespace p="http://www.w3.org/ns/xproc";&#xD;
 declare namespace c="http://www.w3.org/ns/xproc-step";&#xD;
 declare namespace err="http://www.w3.org/ns/xproc-error";&#xD;
 declare namespace xsl="http://www.w3.org/1999/XSL/Transform";&#xD;
 declare namespace t="http://xproc.org/ns/testsuite";&#xD;
&#xD;
 (: Module Imports :)&#xD;
 import module namespace const = "http://xproc.net/xproc/const" at "resource:net/xproc/xprocxq/src/xquery/const.xqm";&#xD;
 import module namespace u = "http://xproc.net/xproc/util" at "resource:net/xproc/xprocxq/src/xquery/util.xqm";&#xD;
 import module namespace opt = "http://xproc.net/xproc/opt" at "resource:net/xproc/xprocxq/src/xquery/opt.xqm";&#xD;
 import module namespace std = "http://xproc.net/xproc/std" at "resource:net/xproc/xprocxq/src/xquery/std.xqm";&#xD;
 import module namespace ext = "http://xproc.net/xproc/ext" at "resource:net/xproc/xprocxq/src/xquery/ext.xqm";&#xD;
 import module namespace naming = "http://xproc.net/xproc/naming" at "resource:net/xproc/xprocxq/src/xquery/naming.xqm";&#xD;
&#xD;
 (: disallow xinclude for p:xinclude step to manage:)&#xD;
 declare option exist:serialize "expand-xincludes=no";&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare variable $xproc:run-step := util:function(xs:QName("xproc:run-step"), 5);&#xD;
 declare variable $xproc:parse-and-eval := util:function(xs:QName("xproc:parse_and_eval"), 5);&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare variable $xproc:declare-step :=util:function(xs:QName("xproc:declare-step"), 5);&#xD;
 declare variable $xproc:choose       :=util:function(xs:QName("xproc:choose"), 5);&#xD;
 declare variable $xproc:try          :=util:function(xs:QName("xproc:try"), 5);&#xD;
 declare variable $xproc:catch        :=util:function(xs:QName("xproc:catch"), 5);&#xD;
 declare variable $xproc:group        :=util:function(xs:QName("xproc:group"), 5);&#xD;
 declare variable $xproc:for-each     :=util:function(xs:QName("xproc:for-each"), 5);&#xD;
 declare variable $xproc:viewport     :=util:function(xs:QName("xproc:viewport"), 5);&#xD;
 declare variable $xproc:library      :=util:function(xs:QName("xproc:library"), 4);&#xD;
 declare variable $xproc:pipeline     :=util:function(xs:QName("xproc:pipeline"), 4);&#xD;
 declare variable $xproc:variable     :=util:function(xs:QName("xproc:variable"), 4);&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
 (: ------------------------------------------------------------------------------------------ :)&#xD;
                                                                           (: XPROC COMPONENTS :)&#xD;
 (: ------------------------------------------------------------------------------------------ :)&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:declare-step($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    let $v := u:get-primary($primary)&#xD;
    return&#xD;
	    $v&#xD;
 };&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:for-each($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
 let $iteration-select := string($currentstep/xproc:iteration-source/@select)&#xD;
 let $v :=&#xD;
 if ($currentstep/xproc:iteration-source/p:empty) then&#xD;
           xproc:resolve-empty-binding()&#xD;
&#xD;
else if($currentstep/xproc:iteration-source/p:inline) then&#xD;
          xproc:resolve-inline-binding($currentstep/xproc:iteration-source/p:inline)&#xD;
&#xD;
else if($currentstep/xproc:iteration-source/p:document) then&#xD;
          xproc:resolve-document-binding($currentstep/xproc:iteration-source/p:inline)&#xD;
&#xD;
else if($currentstep/xproc:iteration-source/p:data) then&#xD;
          xproc:resolve-data-binding($currentstep/xproc:iteration-source/p:inline)&#xD;
&#xD;
 else if ($iteration-select ne '') then&#xD;
   u:xpathexpression($iteration-select, u:get-primary($primary), $currentstep)&#xD;
 else&#xD;
   u:get-primary($primary)&#xD;
 let $defaultname := concat(string($currentstep/@xproc:defaultname),'.0')&#xD;
 let $subpipeline := $currentstep/*[not(name(.) eq 'ext:pre')][not(name(.) eq 'xproc:iteration-source')]&#xD;
 let $namespaces := xproc:enum-namespaces($subpipeline)&#xD;
&#xD;
 return&#xD;
    if (empty($v)) then&#xD;
        ()&#xD;
    else&#xD;
        for $child at $count in $v&#xD;
        let $iteration-source := (&lt;xproc:output step="{concat(string($currentstep/@xproc:defaultname), '.1')}"&#xD;
                       port-type="output"&#xD;
                       primary="true"&#xD;
                       xproc:defaultname="$defaultname"&#xD;
                       select="/"&#xD;
                       port="result"&#xD;
                       func="$xproc:for-each"&gt;&#xD;
                        {$child}&#xD;
                      &lt;/xproc:output&gt;&#xD;
                      ,&lt;xproc:output step="{concat(string($currentstep/@xproc:defaultname),'.2')}"&#xD;
                       port-type="output"&#xD;
                       primary="true"&#xD;
                       xproc:defaultname="$defaultname"&#xD;
                       select="/"&#xD;
                       port="result"&#xD;
                       func="$xproc:for-each"&gt;&#xD;
                        {$child}&#xD;
                      &lt;/xproc:output&gt;)&#xD;
        let $result :=&#xD;
            (u:call($xproc:parse-and-eval,&lt;p:declare-step xproc:defaultname="{$defaultname}" &gt;&#xD;
&#xD;
            {$subpipeline}&lt;/p:declare-step&gt;,$namespaces,$child,(),($outputs,$iteration-source))/.)[last()]&#xD;
        return&#xD;
            for $item in $result&#xD;
            return&#xD;
                $item/*&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:replace-matching-elements($element as element(),$select,$defaultname,$currentstep,$outputs) as element() {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
   let $namespaces := xproc:enum-namespaces($currentstep)&#xD;
   return&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
                          (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;{$currentstep/node()}&lt;/p:declare-step&gt;,(),$child,(),$outputs)/.)[last()]/node()&#xD;
    			    else&#xD;
                        xproc:replace-matching-elements($child,$select,$defaultname,$currentstep,$outputs)&#xD;
                else&#xD;
                    $child&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
(: ------------------------------------------------------------------------------- :)&#xD;
declare function xproc:viewport($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
(: ------------------------------------------------------------------------------- :)&#xD;
     let $v := u:get-primary($primary)&#xD;
     let $match := string($currentstep/@match[1])&#xD;
     let $query := if (contains($match,'/')) then&#xD;
                    $match&#xD;
                  else&#xD;
                    concat('.//',$match)&#xD;
     let $matchresult := u:evalXPATH($match, $v, $primary)&#xD;
     let $defaultname := concat(string($currentstep/@xproc:defaultname),'.0')&#xD;
     return&#xD;
&#xD;
        for $child in $v/node()&#xD;
        return&#xD;
            xproc:replace-matching-elements($child,&#xD;
                                            $matchresult,&#xD;
                                            $defaultname,&#xD;
                                            $currentstep,&#xD;
                                            $outputs)&#xD;
 };&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:library($primary,$secondary,$options,$step) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    &lt;test4/&gt;&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:pipeline($primary,$secondary,$options,$step) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    &lt;test5/&gt;&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:variable($primary,$secondary,$options,$step) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    &lt;test6/&gt;&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:group($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    let $v := u:get-primary($primary)&#xD;
    let $namespaces := xproc:enum-namespaces($currentstep)&#xD;
    let $defaultname := concat(string($currentstep/@xproc:defaultname),'.0')&#xD;
    return&#xD;
        (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;{$currentstep/node()}&lt;/p:declare-step&gt;,$namespaces,$v,(),$outputs)/.)[last()]/node()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:try($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    let $v := u:get-primary($primary)&#xD;
    let $defaultname := concat(string($currentstep/@xproc:defaultname),'.0')&#xD;
    let $namespaces := xproc:enum-namespaces($currentstep/p:group)&#xD;
    return&#xD;
&#xD;
         util:catch('*',&#xD;
             (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;&#xD;
                 {$currentstep/p:group}&lt;/p:declare-step&gt;,$namespaces,$v,(),$outputs)/.)[last()]/node(),&#xD;
             (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;&#xD;
                 {$currentstep/p:catch}&lt;/p:declare-step&gt;,$namespaces,$v,(),$outputs)/.)[last()]/node())&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:catch($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    let $v := u:get-primary($primary)&#xD;
    let $namespaces := xproc:enum-namespaces($currentstep)&#xD;
    let $defaultname := concat(string($currentstep/@xproc:defaultname),'.0')&#xD;
    return&#xD;
        (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;{$currentstep/node()}&lt;/p:declare-step&gt;,$namespaces,$v,(),$outputs)/.)[last()]/node()&#xD;
 };&#xD;
&#xD;
&#xD;
(: ----------------------------------------------------------------------------- :)&#xD;
declare function xproc:choose($primary,$secondary,$options,$currentstep,$outputs) {&#xD;
(: ----------------------------------------------------------------------------- :)&#xD;
 let $v :=if ($currentstep/xproc:xpath-context/p:empty) then&#xD;
           xproc:resolve-empty-binding()&#xD;
&#xD;
        else if($currentstep/xproc:xpath-context/p:inline) then&#xD;
                  xproc:resolve-inline-binding($currentstep/xproc:xpath-context/p:inline)&#xD;
&#xD;
        else if($currentstep/xproc:xpath-context/p:document) then&#xD;
                  xproc:resolve-document-binding($currentstep/xproc:xpath-context/p:inline)&#xD;
&#xD;
        else if($currentstep/xproc:xpath-context/p:data) then&#xD;
                  xproc:resolve-data-binding($currentstep/xproc:xpath-context/p:inline)&#xD;
        else&#xD;
           u:get-primary($primary)&#xD;
&#xD;
    let $namespaces := xproc:enum-namespaces($currentstep)&#xD;
    &#xD;
    let $defaultname := concat(string($currentstep/@xproc:defaultname),'.0')&#xD;
    let $xpath-context-output := &lt;xproc:output step="{$defaultname}"&#xD;
                   port-type="output"&#xD;
                   primary="false"&#xD;
                   xproc:defaultname="$defaultname"&#xD;
                   select="/"&#xD;
                   port="xpath-context"&#xD;
                   func="$xproc:choose"&gt;&#xD;
                    {$v}&#xD;
                  &lt;/xproc:output&gt;&#xD;
&#xD;
     let $whens := $currentstep/p:when&#xD;
     let $otherwise := $currentstep/p:otherwise&#xD;
&#xD;
    let $when := (&#xD;
        for $when in $whens&#xD;
            let $when_eval := u:xquery(string($when/@test),$v, $outputs//xproc:variable)&#xD;
            return&#xD;
                if($when_eval) then&#xD;
                    $when&#xD;
                else&#xD;
                    ()&#xD;
        )&#xD;
    return&#xD;
        if ($when) then&#xD;
            (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;{$when/node()}&lt;/p:declare-step&gt;,$namespaces,$v,(),$outputs)/.)[last()]/node()&#xD;
         else&#xD;
            (u:call($xproc:parse-and-eval,&lt;p:declare-step name="{$defaultname}" xproc:defaultname="{$defaultname}" &gt;{$otherwise/node()}&lt;/p:declare-step&gt;,$namespaces,$v,(),$outputs)/.)[last()]/node()&#xD;
&#xD;
 };&#xD;
&#xD;
&#xD;
 (: ------------------------------------------------------------------------ :)&#xD;
 declare function xproc:run-step($primary,$secondary,$options,$step,$outputs) {&#xD;
 (: ------------------------------------------------------------------------ :)&#xD;
    let $v := u:get-primary($primary)&#xD;
    let $pipeline := u:get-secondary('pipeline',$secondary)&#xD;
    let $bindings := u:get-secondary('bindings',$secondary)&#xD;
    let $dflag := u:get-option('dflag',$options,$v)&#xD;
    let $tflag := u:get-option('tflag',$options,$v)&#xD;
    let $step-options := ()&#xD;
    return&#xD;
        xproc:run($pipeline,$primary,$dflag,$tflag,$bindings,$step-options,$outputs)&#xD;
 };&#xD;
&#xD;
&#xD;
 (: ----------------------------------------------------------------------------------- :)&#xD;
                                                                 (: PREPARSE II UTILS   :)&#xD;
 (: ----------------------------------------------------------------------------------- :)&#xD;
&#xD;
 (: ---------------------------------------------------------------- :)&#xD;
 declare function xproc:get-step($stepname as xs:string,$declarestep) {&#xD;
 (: ---------------------------------------------------------------- :)&#xD;
&#xD;
     $const:std-steps/p:declare-step[@type=$stepname],&#xD;
     $const:opt-steps/p:declare-step[@type=$stepname],&#xD;
     $const:ext-steps/p:declare-step[@type=$stepname],&#xD;
     $declarestep/@type&#xD;
 };&#xD;
&#xD;
&#xD;
 (: ----------------------------------------------------------------------------- :)&#xD;
 declare function xproc:type($stepname as xs:string,$is_declare-step) as xs:string {&#xD;
 (: ----------------------------------------------------------------------------- :)&#xD;
 (: TODO - refactor at some point perhaps using base-uri ? :)&#xD;
&#xD;
 let $stdstep := $const:std-steps/p:declare-step[@type=$stepname]&#xD;
 let $optstep := $const:opt-steps/p:declare-step[@type=$stepname]&#xD;
 let $extstep := $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
 let $component :=$const:comp-steps//xproc:element[@type=$stepname]&#xD;
&#xD;
 let $stdstepexists := exists($stdstep)&#xD;
 let $optstepexists := exists($optstep)&#xD;
 let $extstepexists := exists($extstep)&#xD;
 let $compexists := exists($component)&#xD;
 return&#xD;
     if ($optstepexists) then&#xD;
         'opt'&#xD;
     else if($extstepexists) then&#xD;
         'ext'&#xD;
     else if($stdstepexists) then&#xD;
         'std'&#xD;
     else if($compexists) then&#xD;
         'xproc'&#xD;
     else if($is_declare-step) then&#xD;
       string(substring-before($is_declare-step/@type,':'))&#xD;
     else&#xD;
       u:staticError('err:XS0044', concat($stepname,":",$stepname,' has no visible declaration'))&#xD;
 };&#xD;
&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------------------- :)&#xD;
                                                                    (: PREPARSE II ROUTINES:)&#xD;
 (: -------------------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:generate-explicit-input($step,$count,$xproc,$unique_before,$unique_id,$allstep){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
 (: TODO - this section will be refactored:)&#xD;
 for $input in $step/p:input&#xD;
     return&#xD;
         if($input/*) then&#xD;
             $input&#xD;
         else&#xD;
             element {node-name($input)}{&#xD;
                attribute port{$input/@port},&#xD;
                attribute primary{if (empty($input/@primary)) then 'true' else $input/@primary},&#xD;
                attribute select{if(empty($input/@select)) then string('/') else $input/@select},&#xD;
&#xD;
                if ($input/p:document or $input/p:inline or $input/p:empty or $input/p:data) then&#xD;
                     $input/*&#xD;
                else if($input/@primary eq 'false') then&#xD;
                    (: ensure required non primary inputs are bound :)&#xD;
                    if($allstep/p:input[@port = $input/@port][@xproc:required eq 'true']) then&#xD;
                        u:staticError('err:XS0032', concat("static error during explicit binding pass:",$input,$allstep))&#xD;
                    else&#xD;
                        $input/*&#xD;
                else if(name($step)="ext:pre" or name($step)="ext:post" ) then&#xD;
                    let $a := $unique_before&#xD;
                    let $a1 := substring-before($a,'.0')&#xD;
                    let $b := tokenize($a1,'\.')[last()]&#xD;
                    let $c := substring-before($a1,$b)&#xD;
                    return&#xD;
                        if($input/*/p:pipe or contains($b,'!')) then&#xD;
                            $input/*&#xD;
                        else&#xD;
                        let $d := xs:integer($b) - 1&#xD;
                        let $e := concat($c,$d)&#xD;
                        return&#xD;
                            if ($e eq '') then&#xD;
                                let $part  := tokenize($unique_id,'\.')[last()]&#xD;
                                let $part1 := xs:integer($part) - 1&#xD;
                                let $part2 := substring-before($unique_id,$part)&#xD;
                                let $part3 := concat($part2,$part1)&#xD;
                                return&#xD;
                                    &lt;p:pipe step="{$part3}" port="result"/&gt;&#xD;
                            else&#xD;
                                &lt;p:pipe step="{$e}" port="result"/&gt;&#xD;
                else&#xD;
                    let $l_count := $count - 1&#xD;
                    return&#xD;
                        if($l_count=0) then&#xD;
                            &lt;p:pipe step="{substring-before($unique_id,'.1')}"&#xD;
                                    port="source"/&gt;&#xD;
                        else&#xD;
                            &lt;p:pipe step="{&#xD;
                                    if (empty(string($xproc/*[$l_count]/@name)) or string($xproc/*[$l_count]/@name) eq '') then&#xD;
                                        $unique_before&#xD;
                                    else&#xD;
                                        $xproc/*[$l_count]/@name&#xD;
                                        }"&#xD;
                             port="{if ($xproc/*[$l_count]/p:output[@primary='true']/@port) then&#xD;
                                      $xproc/*[$l_count]/p:output[@primary='true']/@port&#xD;
                                    else&#xD;
                                      'result'&#xD;
&#xD;
                                      }"/&gt;&#xD;
                }&#xD;
 };&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:generate-explicit-output($step){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
       for $output in $step/p:output&#xD;
         return&#xD;
             $output&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:generate-explicit-options($step){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
       for $option in $step/p:with-option&#xD;
         return&#xD;
             $option&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:generate-step-binding($step,$xproc,$count,$stepname,$is_declare-step,$unique_id,$unique_before,$allstep){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
             element {if (empty($allstep/@xproc:use-function)) then node-name($step) else $allstep/@xproc:use-function} {&#xD;
                 attribute name{ if(empty(string($step/@name)) or string($step/@name) eq '') then $unique_id else $step/@name},&#xD;
                 attribute xproc:defaultname{$unique_id},&#xD;
                 attribute xproc:type{xproc:type($stepname,$is_declare-step)},&#xD;
                 attribute xproc:step{if (empty($allstep/@xproc:use-function)) then concat('$',xproc:type($stepname,$is_declare-step),':',local-name($step)) else concat('$',$allstep/@xproc:use-function)},&#xD;
                 xproc:generate-explicit-input($step,$count,$xproc,$unique_before,$unique_id,$allstep),&#xD;
                 xproc:generate-explicit-output($step),&#xD;
                 xproc:generate-explicit-options($step)&#xD;
             }&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:generate-component-binding($step,$xproc,$count,$stepname,$is_declare-step,$unique_id,$unique_before,$compstep){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
             element {node-name($step)} {&#xD;
                $step/@*,&#xD;
                 if ($const:comp-steps/xproc:element[@type=$stepname]/@xproc:step) then attribute xproc:defaultname{$unique_id} else (),&#xD;
                 attribute xproc:type{xproc:type($stepname,$is_declare-step)},&#xD;
                if ($const:comp-steps/xproc:element[@type=$stepname]/@xproc:step) then attribute xproc:step{concat('$',xproc:type($stepname,$is_declare-step),':',local-name($step))} else (),&#xD;
                xproc:generate-explicit-input($step,$count,$xproc,$unique_before,$unique_id,$compstep),&#xD;
                xproc:explicitbindings(document{$step/*[not(name(.) eq 'p:input')][not(name(.) eq 'p:output')]},$unique_id)&#xD;
             }&#xD;
 };&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:generate-declare-step-binding($step,$is_declare-step){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
     $step&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function xproc:explicitbindings($xproc,$unique_id){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
 let $pipelinename := $xproc/@name&#xD;
 let $explicitbindings := document {&#xD;
&#xD;
     for $step at $count in $xproc/*&#xD;
&#xD;
         let $stepname := name($step)&#xD;
&#xD;
         let $unique_before := u:uniqueid($unique_id,$count - 1)&#xD;
         let $unique_current := u:uniqueid($unique_id,$count)&#xD;
         let $unique_after := u:uniqueid($unique_id,$count + 1)&#xD;
&#xD;
         let $is_declare-step := $xproc//p:declare-step[@type=$stepname]&#xD;
         let $is_step := xproc:get-step($stepname,$is_declare-step)&#xD;
         let $is_component := u:get-comp($stepname)&#xD;
&#xD;
           return&#xD;
             if ($stepname eq 'xproc:variable' or $stepname eq 'xproc:iteration-source') then&#xD;
                $step&#xD;
             else if ($is_declare-step) then&#xD;
                xproc:generate-declare-step-binding($step,$is_declare-step)&#xD;
             else if($is_step) then&#xD;
                xproc:generate-step-binding($step,$xproc,$count,$stepname,$is_declare-step,$unique_current,$unique_before,$is_step)&#xD;
             else if ($is_component) then&#xD;
                xproc:generate-component-binding($step,$xproc,$count,$stepname,$is_declare-step,$unique_current,$unique_before,$is_component)&#xD;
             else&#xD;
                 u:staticError('err:XS0044', concat("static error during explicit binding pass:",$stepname,$step/@name,$is_declare-step,$is_step,$is_component))&#xD;
     }&#xD;
&#xD;
     return&#xD;
         (: if dealing with nested components --------------------------------------------------------- :)&#xD;
         if(empty($pipelinename)) then&#xD;
             $explicitbindings&#xD;
         else&#xD;
         (: if dealing with p:pipeline component ------------------------------------------------------ :)&#xD;
             &lt;p:declare-step xmlns:xproc="http://xproc.net/xproc"&#xD;
                             name="{$pipelinename}"&#xD;
                             xproc:defaultname="{$unique_id}"&gt;&#xD;
                 {$explicitbindings}&#xD;
             &lt;/p:declare-step&gt;&#xD;
 };&#xD;
&#xD;
&#xD;
&#xD;
 (: ------------------------------------------------------------------------------------------ :)&#xD;
                                                                      (: RUN TIME EVAL ROUTINES:)&#xD;
 (:--------------------------------------------------------------------------------------------:)&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-empty-binding(){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    ()&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-inline-binding($child){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    $child/node()&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-document-binding($child){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    if (doc-available(string($child/@href))) then&#xD;
        doc(string($child/@href))&#xD;
    else&#xD;
        u:dynamicError('err:XD0002',concat(" cannot access document ",$child/@href))&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-data-binding($child){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    if ($child/@href) then&#xD;
    element {&#xD;
    if ($child/@wrapper) then&#xD;
        string($child/@wrapper)&#xD;
    else&#xD;
        'c:data'&#xD;
    } {&#xD;
    &#xD;
        if ($child/@xproc:escape eq 'true') then&#xD;
            attribute xproc:escape{'true'}&#xD;
        else&#xD;
            (),&#xD;
        if (starts-with($child/@href,'file:')) then&#xD;
              util:binary-doc($child/@href)&#xD;
        else if (ends-with($child/@href,'.xml')) then&#xD;
        let $result :=  doc($child/@href)&#xD;
        let $namespaces := u:declare-ns(xproc:enum-namespaces($result))&#xD;
        return&#xD;
          $result&#xD;
        &#xD;
        else&#xD;
	        util:binary-to-string(util:binary-doc($child/@href))&#xD;
&#xD;
&#xD;
(:          u:unparsed-data($child/@href,'text/plain')&#xD;
:)&#xD;
    }&#xD;
  else&#xD;
     u:dynamicError('err:XD0002',concat("cannot access document:  ",$child/@href))&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-stdin-binding($result,$current-step-name){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    $result/xproc:output[@port eq 'stdin'][@step eq $current-step-name]/node()&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-primary-input-binding($result,$pipeline-name){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    $result/xproc:output[@step eq concat('!',$pipeline-name)][@port eq '' or @port eq 'result']/node()&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-non-primary-input-binding($result,$child,$pipeline-name){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    $result/xproc:output[@port eq $child/@port][@step eq concat('!',$pipeline-name)]/node()&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-pipe-binding($result,$child){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
&#xD;
    if ($result/xproc:output[@port=$child/@port][@step eq $child/@step]) then&#xD;
        $result/xproc:output[@port=$child/@port][@step eq $child/@step]/node()&#xD;
    else if ($result/xproc:output[@port=$child/@port][@xproc:defaultname eq $child/@step]) then &#xD;
        $result/xproc:output[@port=$child/@port][@xproc:defaultname eq $child/@step]/node()&#xD;
    else&#xD;
        $result/xproc:output[last()]/node()&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-port-binding($child,$result,$pipeline,$currentstep){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    if(name($child)='p:empty') then&#xD;
          xproc:resolve-empty-binding()&#xD;
&#xD;
     else if(name($child) eq 'p:inline') then&#xD;
         xproc:resolve-inline-binding($child)&#xD;
&#xD;
     else if(name($child)='p:document') then&#xD;
         xproc:resolve-document-binding($child)&#xD;
&#xD;
     else if(name($child)='p:data') then&#xD;
         xproc:resolve-data-binding($child)&#xD;
&#xD;
     else if ($child/@port eq 'stdin' and $child/@step eq $pipeline/@name) then&#xD;
         xproc:resolve-stdin-binding($result,$currentstep/@name)&#xD;
&#xD;
     else if ($child/@primary eq 'true' and $child/@step eq $pipeline/@name) then&#xD;
        xproc:resolve-primary-input-binding($result,$pipeline/@name)&#xD;
&#xD;
     else if ($child/@step eq $pipeline/@name) then&#xD;
        xproc:resolve-non-primary-input-binding($result,$child,$pipeline/@name)&#xD;
&#xD;
     else if ($child/@port and $child/@step) then&#xD;
        xproc:resolve-pipe-binding($result,$child)&#xD;
&#xD;
    else&#xD;
        u:dynamicError('err:XD0001',concat(" cannot bind to port: ",$child/@port," step: ",$child/@step,' ',u:serialize($currentstep,$const:TRACE_SERIALIZE)))&#xD;
&#xD;
 };&#xD;
&#xD;
&#xD;
 (:---------------------------------------------------------------------------:)&#xD;
 declare function xproc:eval-primary($pipeline,$step,$currentstep,$primaryinput,$result){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 let $primaryresult := document{&#xD;
     if($currentstep/p:input[@primary eq 'true']/node()) then&#xD;
        (: resolve each nested port binding :)&#xD;
         for $child in $currentstep/p:input[@primary eq 'true']/node()&#xD;
             return&#xD;
                xproc:resolve-port-binding($child,$result,$pipeline,$currentstep)&#xD;
     else&#xD;
            $primaryinput/node() (: prev step is an atomic step output:)&#xD;
     }&#xD;
&#xD;
    let $select := string($currentstep/p:input[@primary='true']/@select)&#xD;
    let $selectval := if ($select eq '/' or $select eq '') then&#xD;
                        $primaryresult&#xD;
                     else&#xD;
                        u:evalXPATH(string($select),$primaryresult)&#xD;
        return&#xD;
&#xD;
             if (empty($selectval)) then&#xD;
                u:dynamicError('err:XD0016',concat(string($pipeline/*[@name=$step]/p:input[@primary='true'][@select]/@select)," did not select anything at ",$step," ",name($pipeline/*[@name=$step])))&#xD;
             else&#xD;
                 $selectval&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:eval-secondary($pipeline,$step,$currentstep,$primaryinput,$result){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
     &lt;xproc:inputs&gt;{&#xD;
         for $input in $currentstep/p:input[@primary eq 'false']&#xD;
             return&#xD;
             &lt;xproc:input port="{$input/@port}" select="{$input/@select}"&gt;&#xD;
             {&#xD;
                 let $primaryresult := document{&#xD;
                     for $child in $input/node()&#xD;
                     return&#xD;
                         xproc:resolve-port-binding($child,$result,$pipeline,$currentstep)&#xD;
                        }&#xD;
&#xD;
                 let $select := string(&#xD;
                            if ($input/@select eq '/' or empty($input/@select) or $input/@select eq ' ') then&#xD;
                                 '/'&#xD;
                            else&#xD;
                                 string($input/@select)&#xD;
                             )&#xD;
&#xD;
                 let $selectval := if ($select eq '/' or empty($select)) then&#xD;
                                        $primaryresult&#xD;
                                 else&#xD;
                                        let $namespaces :=   u:list-used-namespaces ($primaryresult)&#xD;
                                            return&#xD;
                                                u:evalXPATH(string($select),$primaryresult)&#xD;
                    return&#xD;
                         if (empty($selectval)) then&#xD;
&#xD;
         (: TODO: investigate empty bindings :)&#xD;
          u:dynamicError('err:XD0016',concat(string($pipeline/*[@name=$step]/p:input[@primary='true'][@select]/@select)," did not select anything at ",$step," ",name($pipeline/*[@name=$step])))&#xD;
                         else&#xD;
                             $selectval&#xD;
             }&#xD;
             &lt;/xproc:input&gt;&#xD;
&#xD;
     }&lt;/xproc:inputs&gt;&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:eval-options($pipeline,$step){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
     &lt;xproc:options&gt;&#xD;
         {$pipeline/*[@name=$step]/p:with-option}&#xD;
     &lt;/xproc:options&gt;&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:eval-outputs($pipeline,$step){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
     &lt;xproc:outputs&gt;&#xD;
         {$pipeline/*[@name=$step]/p:output}&#xD;
     &lt;/xproc:outputs&gt;&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:evalstep ($step,$namespaces,$primaryinput,$pipeline,$outputs) {&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
     let $outputs := document{$outputs}&#xD;
     let $variables :=  $outputs//xproc:variable&#xD;
     let $declarens :=  u:declare-ns($namespaces)&#xD;
     let $currentstep := $pipeline/*[@name=$step][1]&#xD;
     let $stepfuncname := $currentstep/@xproc:step&#xD;
     let $stepfunc := concat($const:default-imports,$stepfuncname)&#xD;
     let $primary := xproc:eval-primary($pipeline,$step,$currentstep,$primaryinput,$outputs)&#xD;
     let $secondary := xproc:eval-secondary($pipeline,$step,$currentstep,$primaryinput,$outputs)&#xD;
&#xD;
     let $options := xproc:eval-options($pipeline,$step)&#xD;
     let $output := xproc:eval-outputs($pipeline,$step)&#xD;
&#xD;
     let $log-href := $currentstep/p:log/@href&#xD;
     let $log-port := $currentstep/p:log/@port&#xD;
&#xD;
     return&#xD;
         if(name($currentstep) = "p:declare-step") then&#xD;
            (: TODO: refactor p:pipeline and p:declare-step :)&#xD;
             ()&#xD;
         else&#xD;
            let $primaryinput:= &lt;xproc:output step="{$step}"&#xD;
                           port-type="input"&#xD;
                           primary="true"&#xD;
                           select="{$currentstep/p:input[1][@primary='true']/@select}"&#xD;
                           port="{$currentstep/p:input[1][@primary='true']/@port}"&#xD;
                           func="{$stepfuncname}"&gt;{&#xD;
                                      $primary/node()&#xD;
                          }&#xD;
                     &lt;/xproc:output&gt;&#xD;
            let $secondaryinput: =(  for $child in $secondary/xproc:input&#xD;
                 return&#xD;
                     &lt;xproc:output step="{$step}"&#xD;
                           port-type="input"&#xD;
                           primary="false"&#xD;
                           select="{$child/@select}"&#xD;
                           port="{$child/@port}"&#xD;
                           func="{$stepfuncname}"&gt;{&#xD;
                             $child/node()&#xD;
                           }&#xD;
                     &lt;/xproc:output&gt;&#xD;
                    )&#xD;
            return&#xD;
                ($primaryinput,&#xD;
                $secondaryinput,&#xD;
                if($currentstep/p:output[@primary='true']) then&#xD;
                      &lt;xproc:output step="{$step}"&#xD;
                                       port-type="output"&#xD;
                                       primary="true"&#xD;
                                       xproc:defaultname="{$currentstep/@xproc:defaultname}"&#xD;
                                       select="{$currentstep/p:output[@primary='true']/@select}"&#xD;
                                       port="{$currentstep/p:output[@primary='true']/@port}"&#xD;
                                       func="{$stepfuncname}"&gt;{&#xD;
                                           if(contains($stepfuncname,'xproc:')) then&#xD;
                                             u:call(u:xquery($stepfunc),$primary,$secondary,$options,$currentstep,($outputs,$primaryinput,$secondaryinput))&#xD;
                                           else&#xD;
                                             u:call(u:xquery($stepfunc),$primary,$secondary,$options, $variables)&#xD;
                                       }&#xD;
                      &lt;/xproc:output&gt;&#xD;
                else&#xD;
                      &lt;xproc:output step="{$step}"&#xD;
                                       port-type="output"&#xD;
                                       primary="false"&#xD;
                                       xproc:defaultname="{$currentstep/@xproc:defaultname}"&#xD;
                                       select="{$currentstep/p:output[@primary='false']/@select}"&#xD;
                                       port="{if (empty($currentstep/p:output[@primary='false']/@port)) then 'result' else $currentstep/p:output[@primary='false']/@port}"&#xD;
                                       func="{$stepfuncname}"&gt;&#xD;
                                       {&#xD;
                                           if(contains($stepfuncname,'xproc:')) then&#xD;
                                             u:call(u:xquery($stepfunc),$primary,$secondary,$options,$currentstep,($outputs,$primaryinput,$secondaryinput))&#xD;
                                           else&#xD;
                                             u:call(u:xquery($stepfunc),$primary,$secondary,$options,$variables)&#xD;
                                       }&#xD;
                      &lt;/xproc:output&gt;&#xD;
             )&#xD;
 };&#xD;
&#xD;
 (: ------------------------------------------------------------------------------------------ :)&#xD;
                                                                           (: CONTROL ROUTINES:)&#xD;
 (: ------------------------------------------------------------------------------------------ :)&#xD;
&#xD;
&#xD;
 (: --------------------------------------------------------------------------- :)&#xD;
 declare function xproc:genstepnames($steps) as xs:string* {&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
     for $step in $steps/*[not(name()='p:documentation')]&#xD;
     return&#xD;
        xs:string($step/@name)&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:parse_and_eval($pipeline,$namespaces,$stdin,$bindings) {&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 let $steps := xproc:genstepnames($pipeline)&#xD;
 return&#xD;
     u:step-fold($pipeline,&#xD;
                 $namespaces,&#xD;
                 $steps,&#xD;
                 util:function(xs:QName("xproc:evalstep"), 5),&#xD;
                 $stdin,&#xD;
                 (xproc:resolve-external-bindings($bindings,$pipeline/@name),&#xD;
                 for $var in $pipeline/xproc:variable&#xD;
                 return&#xD;
                 &lt;xproc:variable name="{$var/@var-name}"&gt;&#xD;
                  {&#xD;
                  let $v :=&#xD;
                  if ($var/p:empty) then&#xD;
                    xproc:resolve-empty-binding()&#xD;
                  else if ($var/p:inline) then&#xD;
                    xproc:resolve-inline-binding($var/p:inline)&#xD;
                  else if ($var/p:document) then&#xD;
                    xproc:resolve-document-binding($var/p:document)&#xD;
                  else if ($var/p:data) then&#xD;
                    xproc:resolve-data-binding($var/p:data)&#xD;
                  else if ($var/p:pipe) then&#xD;
                     $stdin&#xD;
                  else&#xD;
                      $stdin&#xD;
                  return&#xD;
                    u:safe-evalXPATH(string($var/@select),document{$v/*},$pipeline)&#xD;
                  }&#xD;
                 &lt;/xproc:variable&gt;&#xD;
                 ,(&lt;xproc:output&#xD;
                     step="{if ($steps[1] = '|') then &#xD;
                                '!1|'&#xD;
                            else $steps[1]}"&#xD;
                     port="stdin"&#xD;
                     test="test"&#xD;
                     port-type="external"&#xD;
                     primary="false"&#xD;
                     func="{$pipeline/@type}"&gt;{$stdin}&lt;/xproc:output&gt;))&#xD;
     )&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:parse_and_eval($pipeline,$namespaces,$stdin,$bindings,$outputs) {&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
&#xD;
     let $steps := xproc:genstepnames($pipeline)&#xD;
     return&#xD;
         u:step-fold($pipeline,&#xD;
                     $namespaces,&#xD;
                     $steps,&#xD;
                     util:function(xs:QName("xproc:evalstep"), 5),&#xD;
                     $stdin,&#xD;
                    ($outputs,&#xD;
                     xproc:resolve-external-bindings($bindings,$pipeline/@name),&#xD;
                     for $var in $pipeline/xproc:variable&#xD;
                     return&#xD;
                     &lt;xproc:variable name="{$var/@var-name}"&gt;&#xD;
                      {&#xD;
                      let $v :=&#xD;
                      if ($var/p:empty) then&#xD;
                        xproc:resolve-empty-binding()&#xD;
                      else if ($var/p:inline) then&#xD;
                        xproc:resolve-inline-binding($var/p:inline)&#xD;
                      else if ($var/p:document) then&#xD;
                        xproc:resolve-document-binding($var/p:document)&#xD;
                      else if ($var/p:data) then&#xD;
                        xproc:resolve-data-binding($var/p:data)&#xD;
                      else if ($var/p:pipe) then&#xD;
                        xproc:resolve-pipe-binding($outputs,$var/p:pipe)&#xD;
                      else&#xD;
                          $stdin&#xD;
                      return&#xD;
                        u:safe-evalXPATH(string($var/@select),document{$v/*},$pipeline)&#xD;
                      }&#xD;
                     &lt;/xproc:variable&gt;&#xD;
                     ,&#xD;
                     &lt;xproc:output&#xD;
                        step="{concat('!',$pipeline/@name)}"&#xD;
                        port="stdin"&#xD;
                        port-type="external"&#xD;
                        primary="false"&#xD;
                        func="example"&gt;{$stdin}&lt;/xproc:output&gt;&#xD;
                         )&#xD;
                        )&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:enum-namespaces($pipeline){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    &lt;namespace name="{$pipeline/@name}"&gt;{u:enum-ns(&lt;dummy&gt;{util:expand($pipeline)}&lt;/dummy&gt;)}&lt;/namespace&gt;&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:resolve-external-bindings($bindings,$pipelinename){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
if($bindings) then&#xD;
    for $binding in $bindings//*&#xD;
    return&#xD;
        &lt;xproc:output port-type="external" port="{$binding/@port}" step="{concat('!',$pipelinename)}"&gt;&#xD;
            {&#xD;
            if ($binding/@uri) then&#xD;
                doc($binding/@uri)&#xD;
            else&#xD;
                $binding/*&#xD;
            }&#xD;
        &lt;/xproc:output&gt;&#xD;
 else&#xD;
      ()&#xD;
&#xD;
 (:&#xD;
 if ($bindings/t:input) then&#xD;
&#xD;
    (: TODO- this is used for tests.xproc.org unit testing purposes :)&#xD;
    for $binding in $bindings//t:input&#xD;
    return&#xD;
   &lt;xproc:output port-type="external" port="{fn:string($binding/@port)}" step="{concat('!',$pipelinename)}"&gt;&#xD;
       {$binding/.}&#xD;
   &lt;/xproc:output&gt;&#xD;
 else&#xD;
   &lt;xsl:stylesheet/&gt;&#xD;
 :)&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:output($result,$dflag){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 let $pipeline :=subsequence($result,1,1)&#xD;
 let $output := &lt;xproc:outputs&gt;{ subsequence($result,2) } &lt;/xproc:outputs&gt;&#xD;
     return&#xD;
         if($dflag eq "1") then&#xD;
             &lt;xproc:debug&gt;&#xD;
                 &lt;xproc:pipeline&gt;{$pipeline}&lt;/xproc:pipeline&gt;&#xD;
                {$output}&#xD;
             &lt;/xproc:debug&gt;&#xD;
         else&#xD;
            (: TODO - define default p:serialization options here:)&#xD;
            let $stdout := $output//*[@port eq 'stdout']/node()&#xD;
            let $count := count ($result)&#xD;
         return&#xD;
               if (empty($stdout)) then&#xD;
                subsequence($result,$count - 2,1)/node()&#xD;
               else&#xD;
                  $stdout&#xD;
 };&#xD;
&#xD;
 (: ----------------------------------------------------------------------------------- :)&#xD;
                                                                      (: ENTRY POINTS   :)&#xD;
 (: ----------------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:run($pipeline,$stdin){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    xproc:run($pipeline,$stdin,"0","0",(),())&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:run($pipeline,$stdin,$debug){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    xproc:run($pipeline,$stdin,$debug,"0",(),())&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:run($pipeline,$stdin,$debug,$bindings,$options){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    xproc:run($pipeline,$stdin,$debug,"0",$bindings,$options)&#xD;
 };&#xD;
&#xD;
&#xD;
 (: entry point :)&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:run($pipeline,$stdin,$dflag,$tflag,$bindings,$options){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
    let $internaldbg := 1&#xD;
    return&#xD;
         if ($internaldbg eq 1) then&#xD;
                     xproc:explicitbindings(&#xD;
                       naming:explicitnames(&#xD;
                             naming:fixup($pipeline,$stdin)&#xD;
                       )&#xD;
                     ,$const:init_unique_id&#xD;
                     )&#xD;
         else if ($internaldbg eq 2) then&#xD;
                       naming:explicitnames(&#xD;
                             naming:fixup($pipeline,$stdin)&#xD;
                     )&#xD;
         else if ($internaldbg eq 3) then&#xD;
                $bindings&#xD;
         else&#xD;
     (&#xD;
     (: STEP I: generate parse tree :)&#xD;
&#xD;
     let $validate := validation:jing-report($pipeline,fn:doc($const:xproc-rng-schema))&#xD;
     let $namespaces := xproc:enum-namespaces($pipeline)&#xD;
     let $preparse-naming := naming:explicitnames(naming:fixup($pipeline,$stdin))&#xD;
     let $xproc-binding := xproc:explicitbindings($preparse-naming,$const:init_unique_id)&#xD;
&#xD;
     (: STEP II: parse and eval tree :)&#xD;
     let $eval_result := xproc:parse_and_eval($xproc-binding,$namespaces,$stdin,$bindings)&#xD;
&#xD;
     (: STEP III: serialize and return results :)&#xD;
     let $serialized_result := xproc:output($eval_result,string($dflag))&#xD;
     return&#xD;
          if ($tflag="1") then&#xD;
                 document&#xD;
                    {&#xD;
                     &lt;xproc:result xproc:valid="{$validate}" xproc:timing="disabled" xproc:ts="{current-dateTime()}"&gt;&#xD;
                         {&#xD;
                          $serialized_result&#xD;
                         }&#xD;
                     &lt;/xproc:result&gt;&#xD;
                     }&#xD;
              else if ($validate) then&#xD;
                $serialized_result&#xD;
              else&#xD;
                u:xprocxqError('xxq-error:XXQ0003','invalid pipeline.')&#xD;
&#xD;
&#xD;
         )&#xD;
 };&#xD;
&#xD;
&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 declare function xproc:run($pipeline,$stdin,$dflag,$tflag,$bindings,$options,$outputs){&#xD;
 (: -------------------------------------------------------------------------- :)&#xD;
 if (exists($pipeline)) then&#xD;
&#xD;
     let $validate := validation:jing($pipeline,fn:doc($const:xproc-rng-schema))&#xD;
     let $namespaces := xproc:enum-namespaces($pipeline)&#xD;
&#xD;
     (: STEP I: generate parse tree :)&#xD;
     let $preparse-naming := naming:explicitnames(naming:fixup($pipeline,$stdin))&#xD;
     let $xproc-binding := xproc:explicitbindings($preparse-naming,$const:init_unique_id)&#xD;
&#xD;
     (: STEP II: parse and eval tree :)&#xD;
     let $eval_result := xproc:parse_and_eval($xproc-binding,$namespaces,$stdin,$bindings,$outputs)&#xD;
&#xD;
     (: STEP III: serialize and return results :)&#xD;
     let $serialized_result := xproc:output($eval_result,"0")&#xD;
&#xD;
     let $internaldbg := 1&#xD;
&#xD;
     return&#xD;
         if ($internaldbg eq 1) then&#xD;
                     xproc:explicitbindings(&#xD;
                       naming:explicitnames(&#xD;
                             naming:fixup($pipeline,$stdin)&#xD;
                       )&#xD;
                     ,$const:init_unique_id&#xD;
                     )&#xD;
         else if ($internaldbg eq 2) then&#xD;
                       naming:explicitnames(&#xD;
                             naming:fixup($pipeline,$stdin)&#xD;
                       )&#xD;
         else if ($internaldbg eq 3) then&#xD;
                     $eval_result&#xD;
         else&#xD;
         (&#xD;
          if ($tflag="1") then&#xD;
                 document&#xD;
                    {&#xD;
                     &lt;xproc:result xproc:timing="disabled" xproc:ts="{current-dateTime()}"&gt;&#xD;
                         {&#xD;
                          $serialized_result&#xD;
                         }&#xD;
                     &lt;/xproc:result&gt;&#xD;
                     }&#xD;
              else&#xD;
                     $serialized_result&#xD;
         )&#xD;
 else&#xD;
    u:xprocxqError('xxq-error:XXQ0003','check pipeline.')&#xD;
 };</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>