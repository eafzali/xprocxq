<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div id="main"><h1><span class="namespace">http://xproc.net/xproc/naming</span>  library module </h1><div id="variables"><h3>Variables</h3></div><div id="functions"><h3>Functions</h3><div id="func_get-step_1"><h4><pre class="prettyprint lang-xq"><u>Function</u>: get-step($stepname as xs:string)</pre></h4><h5>Params</h5><ul><li>stepname as  xs:string</li></ul></div><div id="func_type_2"><h4><pre class="prettyprint lang-xq"><u>Function</u>: type($stepname as xs:string,$is_declare-step) as  xs:string</pre></h4><h5>Params</h5><ul><li>stepname as  xs:string</li><li>is_declare-step as </li></ul><h5>Returns</h5><ul><li> xs:string</li></ul></div><div id="func_preparse-options_3"><h4><pre class="prettyprint lang-xq"><u>Function</u>: preparse-options($allstep,$step,$stepname)</pre></h4><h5>Params</h5><ul><li>allstep as </li><li>step as </li><li>stepname as </li></ul></div><div id="func_preparse-input-bindings_3"><h4><pre class="prettyprint lang-xq"><u>Function</u>: preparse-input-bindings($allstep,$step,$allbindings)</pre></h4><h5>Params</h5><ul><li>allstep as </li><li>step as </li><li>allbindings as </li></ul></div><div id="func_preparse-output-bindings_3"><h4><pre class="prettyprint lang-xq"><u>Function</u>: preparse-output-bindings($allstep,$step,$allbindings)</pre></h4><h5>Params</h5><ul><li>allstep as </li><li>step as </li><li>allbindings as </li></ul></div><div id="func_pipeline-step-sort_3"><h4><pre class="prettyprint lang-xq"><u>Function</u>: pipeline-step-sort($unsorted, $sorted, $pipelinename)</pre></h4><h5>Params</h5><ul><li>unsorted as </li><li>sorted as </li><li>pipelinename as </li></ul></div><div id="func_generate-step_4"><h4><pre class="prettyprint lang-xq"><u>Function</u>: generate-step($xproc,$is_step,$step,$stepname)</pre></h4><h5>Params</h5><ul><li>xproc as </li><li>is_step as </li><li>step as </li><li>stepname as </li></ul></div><div id="func_generate-component_4"><h4><pre class="prettyprint lang-xq"><u>Function</u>: generate-component($xproc,$is_comp,$step,$stepname)</pre></h4><h5>Params</h5><ul><li>xproc as </li><li>is_comp as </li><li>step as </li><li>stepname as </li></ul></div><div id="func_explicitnames_1"><h4><pre class="prettyprint lang-xq"><u>Function</u>: explicitnames($xproc as item())</pre></h4><h5>Params</h5><ul><li>xproc as  item()</li></ul></div><div id="func_fixup_2"><h4><pre class="prettyprint lang-xq"><u>Function</u>: fixup($xproc as item(),$stdin)</pre></h4><h5>Params</h5><ul><li>xproc as  item()</li><li>stdin as </li></ul></div></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">xquery version "1.0" encoding "UTF-8";&#xD;
module namespace naming = "http://xproc.net/xproc/naming";&#xD;
(: ------------------------------------------------------------------------------------&#xD;
&#xD;
	naming.xqm - manages the first pass parsing of xproc pipeline, providing the output&#xD;
	in topological order and cross referencing step with defined functional signatures.&#xD;
&#xD;
---------------------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
(: XProc Namespace Declaration :)&#xD;
declare namespace p="http://www.w3.org/ns/xproc";&#xD;
declare namespace c="http://www.w3.org/ns/xproc-step";&#xD;
declare namespace err="http://www.w3.org/ns/xproc-erqror";&#xD;
declare namespace xsl="http://www.w3.org/1999/XSL/Transform";&#xD;
declare namespace xproc = "http://xproc.net/xproc";&#xD;
declare namespace xxq-error = "http://xproc.net/xproc/error";&#xD;
&#xD;
(: Module Imports :)&#xD;
import module namespace const = "http://xproc.net/xproc/const" at "resource:net/xproc/xprocxq/src/xquery/const.xqm";&#xD;
import module namespace u = "http://xproc.net/xproc/util" at "resource:net/xproc/xprocxq/src/xquery/util.xqm";&#xD;
import module namespace std = "http://xproc.net/xproc/std" at "resource:net/xproc/xprocxq/src/xquery/std.xqm";&#xD;
import module namespace opt = "http://xproc.net/xproc/opt" at "resource:net/xproc/xprocxq/src/xquery/opt.xqm";&#xD;
import module namespace ext = "http://xproc.net/xproc/ext" at "resource:net/xproc/xprocxq/src/xquery/ext.xqm";&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:get-step($stepname as xs:string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    $const:std-steps/p:declare-step[@type=$stepname],&#xD;
    $const:opt-steps/p:declare-step[@type=$stepname],&#xD;
    $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:type($stepname as xs:string,$is_declare-step) as xs:string {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
    let $stdstep := $const:std-steps/p:declare-step[@type=$stepname]&#xD;
    let $optstep := $const:opt-steps/p:declare-step[@type=$stepname]&#xD;
    let $extstep := $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
    let $component :=$const:comp-steps//xproc:element[@type=$stepname]&#xD;
&#xD;
    let $stdstepexists := exists($stdstep)&#xD;
    let $optstepexists := exists($optstep)&#xD;
    let $extstepexists := exists($extstep)&#xD;
    let $compexists := exists($component)&#xD;
    return&#xD;
        if ($optstepexists) then&#xD;
            'opt'&#xD;
        else if($extstepexists) then&#xD;
            'ext'&#xD;
        else if($stdstepexists) then&#xD;
            'std'&#xD;
        else if($compexists) then&#xD;
            'xproc'&#xD;
        else if($is_declare-step) then&#xD;
          string(substring-before($is_declare-step/@type,':'))&#xD;
        else&#xD;
          u:staticError('err:XS0044', concat($stepname,":",$stepname,' has no visible declaration'))&#xD;
};&#xD;
&#xD;
&#xD;
                     (: --------------------------------------------------------------------------- :)&#xD;
                                                                              (: PREPARSE I ROUTINES:)&#xD;
                     (: --------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:preparse-options($allstep,$step,$stepname){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    for $option in $allstep&#xD;
        return&#xD;
&#xD;
            if ($step/p:with-option[@name=$option/@name] and $step/@*[name(.)=$option/@name]) then&#xD;
&#xD;
               u:staticError('err:XS0027', concat($stepname,":",$step/@name,' option:',$option/@name,' duplicate options'))&#xD;
&#xD;
            else if ($option/@required eq 'true' and $option/@select) then&#xD;
&#xD;
               u:staticError('err:XS0017', concat($stepname,":",$step/@name,' option:',$option/@name,' duplicate options'))&#xD;
&#xD;
            else if ($step/p:with-option[@name=$option/@name]) then&#xD;
&#xD;
               &lt;p:with-option name="{$option/@name}" select="{$step/p:with-option[@name=$option/@name]/@select}"/&gt;&#xD;
&#xD;
            else if($step/@*[name(.)=$option/@name]) then&#xD;
&#xD;
               &lt;p:with-option name="{$option/@name}" select="{concat("'",$step/@*[name(.)=$option/@name],"'")}"/&gt;&#xD;
&#xD;
            else if($option/@select) then&#xD;
&#xD;
               &lt;p:with-option name="{$option/@name}" select="{$option/@select}"/&gt;&#xD;
&#xD;
            else if(not($step/p:with-option[@name=$option/@name] and $step/@*[name(.)=$option/@name]) and $option/@required eq 'true') then&#xD;
&#xD;
                u:staticError('err:XS0018', concat($stepname,":",$step/@name,' option:',$option/@name,' is required and seems to be missing or incorrect'))&#xD;
&#xD;
            else&#xD;
                (: TODO: may have to throw additional errors before this :)&#xD;
                &lt;p:with-option name="{$option/@name}" select="{$option/@default}"/&gt;&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:preparse-input-bindings($allstep,$step,$allbindings){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
if ($allbindings eq 'all') then&#xD;
    $step/p:input&#xD;
else&#xD;
    for $binding in $allstep&#xD;
       let $currentport := $step/*[@port=$binding/@port]&#xD;
        return&#xD;
            element {node-name($binding)} {&#xD;
               $binding/@port,&#xD;
               $binding/@primary,&#xD;
               $binding/@kind,&#xD;
               $binding/@sequence,&#xD;
               if($currentport/@select='') then&#xD;
                  attribute select{$binding/@select}&#xD;
               else if($currentport/@select) then&#xD;
                  $currentport/@select&#xD;
               else&#xD;
                  attribute select{$binding/@select},&#xD;
                   $currentport/*&#xD;
               }&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:preparse-output-bindings($allstep,$step,$allbindings){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
if ($allbindings eq 'all') then&#xD;
    $step/p:output&#xD;
else&#xD;
    for $binding in $allstep&#xD;
       let $currentport := $step/*[@port=$binding/@port]&#xD;
        return&#xD;
            element {node-name($binding)} {&#xD;
               $binding/@port,&#xD;
               $binding/@primary,&#xD;
               $binding/@kind,&#xD;
               $binding/@sequence,&#xD;
               if($currentport/@select='') then&#xD;
                  attribute select{$binding/@select}&#xD;
               else if($currentport/@select) then&#xD;
                  $currentport/@select&#xD;
               else&#xD;
                  attribute select{$binding/@select},&#xD;
                   $currentport/*&#xD;
               }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:pipeline-step-sort($unsorted, $sorted, $pipelinename )  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    if (empty($unsorted)) then&#xD;
        ($sorted)&#xD;
    else&#xD;
        let $allnodes := $unsorted [ every $id in p:input[@primary eq 'true'][@port eq 'source']/p:pipe/@step satisfies ($id = $sorted/@name or $id=$pipelinename)]&#xD;
    return&#xD;
        if ($allnodes) then&#xD;
            naming:pipeline-step-sort( $unsorted except $allnodes, ($sorted, $allnodes ),$pipelinename)&#xD;
        else&#xD;
            ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:generate-step($xproc,$is_step,$step,$stepname){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if($is_step/@xproc:support) then&#xD;
    element {node-name($step)} {&#xD;
        attribute name{$step/@name},&#xD;
		(: TODO - need to fix input/output preparse bindings :)&#xD;
        naming:preparse-input-bindings($is_step/p:*[@primary='true'],$step,$is_step/@xproc:bindings),&#xD;
        naming:preparse-output-bindings($is_step/p:*[@primary='false'],$step,$is_step/@xproc:bindings),&#xD;
        naming:preparse-options($is_step/p:option,$step,$stepname)&#xD;
   }&#xD;
else if($is_step/@type) then&#xD;
    &lt;ext:xproc name="{if ($step/@name) then $step/@name else ''}"&gt;&#xD;
        &lt;p:input port="source" primary="true" select="/"/&gt;&#xD;
        &lt;p:output port="result" primary="true" select=""/&gt;&#xD;
        &lt;p:input port="pipeline" primary="false" select="/"&gt;&#xD;
           &lt;p:inline&gt;&#xD;
                &lt;p:declare-step name="{$step/@name}"&gt;&#xD;
                {$is_step/*}&#xD;
                &lt;/p:declare-step&gt;&#xD;
           &lt;/p:inline&gt;&#xD;
        &lt;/p:input&gt;&#xD;
        &lt;p:input port="bindings" primary="false" select="/"/&gt;&#xD;
        &lt;p:with-option name="dflag" select="'0'"/&gt;&#xD;
        &lt;p:with-option name="tflag" select="'0'"/&gt;&#xD;
    &lt;/ext:xproc&gt;&#xD;
else&#xD;
	u:xprocxqError('xxq-error:XXQ0001',concat($stepname,":",$step/@name,u:serialize($step,$const:TRACE_SERIALIZE)))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:generate-component($xproc,$is_comp,$step,$stepname){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if($is_comp/@xproc:support) then&#xD;
        element {node-name($step)} {&#xD;
            if ($is_comp/@xproc:step = "true") then (attribute name{$step/@name},$step/@*[not(name(.) eq 'name')]) else  $step/@*,&#xD;
&#xD;
            (: TODO - will need to fixup top level input/output ports :)&#xD;
            &lt;ext:pre test="test"&gt;&#xD;
				{naming:preparse-output-bindings($is_comp/p:*[@primary='true'],$step,())}&#xD;
			&lt;/ext:pre&gt;,&#xD;
&#xD;
            naming:explicitnames(document{$step/*})&#xD;
        }&#xD;
else&#xD;
	u:xprocxqError('xxq-error:XXQ0002',concat($stepname,":",$step/@name,u:serialize($step,$const:TRACE_SERIALIZE)))&#xD;
&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:explicitnames($xproc as item()){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
if(empty($xproc/*)) then&#xD;
    ()&#xD;
else&#xD;
    let $pipelinename := $xproc/@name&#xD;
    let $explicitnames :=&#xD;
&#xD;
        for $step at $count in $xproc/*&#xD;
            let $stepname := name($step)&#xD;
            let $is_declared_step := $xproc/p:declare-step[@type=$stepname]&#xD;
            let $is_standard_step := $const:std-steps/p:declare-step[@type=$stepname]&#xD;
            let $is_optional_step := $const:opt-steps/p:declare-step[@type=$stepname]&#xD;
            let $is_extension_step := $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
            let $is_step := ($is_declared_step,&#xD;
                             $is_standard_step,&#xD;
                             $is_optional_step,&#xD;
                             $is_extension_step)&#xD;
            let $is_component := $const:comp-steps//xproc:element[@type=$stepname]&#xD;
            return&#xD;
               if ( name($step) eq 'p:import') then&#xD;
                    ()&#xD;
               else if (name($step) eq 'p:variable') then&#xD;
                    &lt;xproc:variable var-name="{$step/@name}" select="{$step/@select}"&gt;{$step/node()}&lt;/xproc:variable&gt;&#xD;
               else if (name($step) eq 'p:iteration-source') then&#xD;
                    &lt;xproc:iteration-source select="{$step/@select}"&gt;{$step/*}&lt;/xproc:iteration-source&gt;&#xD;
               else if (name($step) eq 'p:xpath-context') then&#xD;
                    &lt;xproc:xpath-context&gt;{$step/*}&lt;/xproc:xpath-context&gt;&#xD;
               else if (name($step) eq 'p:documentation') then&#xD;
                    ()&#xD;
               else if (exists($is_component) and $step/@type)then&#xD;
                    ()&#xD;
               else if(exists($is_step)) then&#xD;
                    (: generate std,opt,ext and declared steps:)&#xD;
                    naming:generate-step($xproc,$is_step,$step,$stepname)&#xD;
               else if (exists($is_component)) then&#xD;
                    (: generate p:declare-step and all other xproc components :)&#xD;
                    naming:generate-component($xproc,$is_component,$step,$stepname)&#xD;
               else&#xD;
                    (: throws error on unknown element in pipeline namespace :)&#xD;
                    u:staticError('err:XS0044', concat(" static error during explicit naming pass:  ",$stepname,":",$step/@name,u:serialize($step,$const:TRACE_SERIALIZE)))&#xD;
    return&#xD;
&#xD;
		let $sorted := naming:pipeline-step-sort($explicitnames,(),$pipelinename)&#xD;
		return&#xD;
        	if(empty($pipelinename))then&#xD;
    			$sorted&#xD;
        	else&#xD;
            	&lt;p:declare-step name="{$pipelinename}"&gt;&#xD;
                {&#xD;
                    $sorted&#xD;
                }&#xD;
                &lt;ext:post name="{$pipelinename}!"&gt;&#xD;
					{$xproc/p:serialization/@*}&#xD;
                    &lt;p:input port="source" primary="true"/&gt;&#xD;
                    &lt;p:output primary="true" port="stdout" select="/"/&gt;&#xD;
                &lt;/ext:post&gt;&#xD;
            	&lt;/p:declare-step&gt;&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function naming:fixup($xproc as item(),$stdin){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $pipeline := $xproc/p:*[name(.) = "p:pipeline" or name(.) ="p:declare-step"]&#xD;
let $pipelinename :=  if (empty($pipeline/@name)) then 'xproc:default-pipeline' else $pipeline/@name&#xD;
let $steps := &lt;p:declare-step name="{$pipelinename}"&gt;&#xD;
               &lt;ext:pre name="!{$pipelinename}"&gt;&#xD;
            {&#xD;
            if ($pipeline/p:input[@primary='true']) then&#xD;
                    $pipeline/p:input[@primary='true']&#xD;
            else if ($pipeline/p:input[@port='source']) then&#xD;
                    &lt;p:input port="source"&#xD;
                             kind="document"&#xD;
                             primary="true"&#xD;
                             select="{if(empty($pipeline/p:input[@port='source']/@select)) then '/' else $pipeline/p:input[@port='source']/@select}"&#xD;
                             sequence="{$pipeline/p:input[@port='source']/@sequence}"&gt;&#xD;
                    {if($stdin) then&#xD;
                        &lt;p:pipe step="{$pipelinename}" port="stdin"/&gt;&#xD;
                    else&#xD;
                        $pipeline/p:input[@port='source'][@primary="true"]&#xD;
                    }&#xD;
                    &lt;/p:input&gt;&#xD;
            else&#xD;
                (),&#xD;
&#xD;
            for $input in $pipeline/p:input[not(@port='source')]&#xD;
            return&#xD;
                &lt;p:input port="{$input/@port}" primary="false"&gt;&#xD;
                    {$input/*}&#xD;
                &lt;/p:input&gt;,&#xD;
&#xD;
            &lt;p:output port="result" primary="true" select="{if ($pipeline/p:output[@port='result']/@select) then $pipeline/p:output[@port='result']/@select else '/' }"/&gt;,&#xD;
&#xD;
            $pipeline/p:output[@primary='false']&#xD;
            }&#xD;
           &lt;/ext:pre&gt;&#xD;
            {&#xD;
               for $import in $xproc/*/p:import&#xD;
                return&#xD;
                    if (doc-available($import/@href)) then&#xD;
                    let $imported := doc($import/@href)&#xD;
                    return&#xD;
                          if ($imported/p:library)then&#xD;
                            $imported/p:library/*&#xD;
                          else&#xD;
                            $imported/p:pipeline/*&#xD;
                    else&#xD;
                          u:dynamicError('XD0002',"cannot import pipeline document ")&#xD;
            }&#xD;
&#xD;
            {$pipeline/*[not(name(.)="p:input")][not(name(.)="p:output")][not(name(.)="p:import")]}&#xD;
&#xD;
&lt;/p:declare-step&gt;&#xD;
return&#xD;
        $steps&#xD;
};&#xD;
&#xD;
&#xD;
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>