<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><meta http-equiv="Authors" content="Copyright 2011 - John Snelson, James Fuller"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div style="text-align:right;"><a href="index.html">XQuery API index</a></div><div id="main"><h1><span class="namespace">http://xproc.net/xproc/util</span>  library module </h1><div><h3>Variables</h3><ul><li>NDEBUG</li></ul></div><div><h3>Functions</h3><h4><pre class="prettyprint lang-xq"><u>Function:</u> declarens($element)</pre></h4><h5>Params</h5><ul><li>: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> declare-ns($namespaces)</pre></h4><h5>Params</h5><ul><li>namespaces: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> enum-ns($element)</pre></h4><h5>Params</h5><ul><li>: </li></ul></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">(: ------------------------------------------------------------------------------------- &#xD;
 &#xD;
	util.xqm - contains most of the XQuery processor specific functions, including all&#xD;
	helper functions.&#xD;
	&#xD;
---------------------------------------------------------------------------------------- :)&#xD;
xquery version "3.0" encoding "UTF-8";&#xD;
&#xD;
module namespace u = "http://xproc.net/xproc/util";&#xD;
&#xD;
(: declare namespaces :)&#xD;
declare namespace p="http://www.w3.org/ns/xproc";&#xD;
declare namespace c="http://www.w3.org/ns/xproc-step";&#xD;
declare namespace err="http://www.w3.org/ns/xproc-error";&#xD;
declare namespace xsl="http://www.w3.org/1999/XSL/Transform";&#xD;
declare namespace xproc = "http://xproc.net/xproc";&#xD;
declare namespace std = "http://xproc.net/xproc/std";&#xD;
declare namespace opt = "http://xproc.net/xproc/opt";&#xD;
declare namespace ext = "http://xproc.net/xproc/ext";&#xD;
declare namespace xxq-error = "http://xproc.net/xproc/error";&#xD;
&#xD;
&#xD;
(: Module Imports :)&#xD;
import module namespace const = "http://xproc.net/xproc/const" at "const.xqm";&#xD;
&#xD;
&#xD;
(: set to 1 to enable debugging :)&#xD;
declare variable $u:NDEBUG :=1;&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: manage namespaces                                                          :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:declarens($element){&#xD;
    u:declare-ns(u:enum-ns($element))&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:declare-ns($namespaces){&#xD;
    for $ns in $namespaces//ns&#xD;
    return&#xD;
        ()&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:enum-ns($element){&#xD;
(&#xD;
let $prefixes := in-scope-prefixes($element)&#xD;
for $prefix in $prefixes&#xD;
return&#xD;
if ($prefix eq 'xml' or $prefix eq '' or $prefix eq 'xproc' or $prefix eq 'ext' or $prefix eq 'opt' or $prefix eq 'p' or $prefix eq 'c') then&#xD;
 ()&#xD;
else&#xD;
&lt;ns prefix="{$prefix}" URI="{namespace-uri-for-prefix($prefix,$element)}"/&gt;&#xD;
,&#xD;
       for $child in $element/node()&#xD;
            return&#xD;
              if ($child instance of element() or $child instance of document-node()) then&#xD;
               	 u:enum-ns($child)&#xD;
                else&#xD;
                  ()&#xD;
)&#xD;
};&#xD;
&#xD;
(:&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: generate unique id														  :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:uniqueid($unique_id,$count) as xs:string{&#xD;
    concat($unique_id,'.',$count)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns comp from comp definitions :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-comp($compname as xs:string) {&#xD;
    $const:comp-steps//xproc:element[@type=$compname]&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: checks to see if this component exists :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:comp-available($compname as xs:string) as xs:boolean {&#xD;
        exists(u:get-comp($compname))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns step from std, opt and ext step definitions :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-step($stepname as xs:string,$declarestep) {&#xD;
    $const:std-steps/p:declare-step[@type=$stepname],&#xD;
    $const:opt-steps/p:declare-step[@type=$stepname],&#xD;
    $const:ext-steps/p:declare-step[@type=$stepname],&#xD;
    $const:comp-steps//xproc:element[@type=$stepname], &#xD;
    $declarestep/@type&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns step type :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:type($stepname as xs:string,$is_declare-step) as xs:string {&#xD;
&#xD;
    let $stdstep := $const:std-steps/p:declare-step[@type=$stepname]&#xD;
    let $optstep := $const:opt-steps/p:declare-step[@type=$stepname]&#xD;
    let $extstep := $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
    let $component :=$const:comp-steps//xproc:element[@type=$stepname]&#xD;
&#xD;
    let $stdstepexists := exists($stdstep)&#xD;
    let $optstepexists := exists($optstep)&#xD;
    let $extstepexists := exists($extstep)&#xD;
    let $compexists := exists($component)&#xD;
    return&#xD;
        if ($optstepexists) then&#xD;
            'opt'&#xD;
        else if($extstepexists) then&#xD;
            'ext'&#xD;
        else if($stdstepexists) then&#xD;
            'std'&#xD;
        else if($compexists) then&#xD;
            'comp'&#xD;
        else if($is_declare-step) then&#xD;
          string(substring-before($is_declare-step/@type,':'))&#xD;
        else&#xD;
          u:staticError('err:XS0044', concat($stepname,":",$stepname,' has no visible declaration'))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:trace($value as item()*, $what as xs:string)  {&#xD;
if(boolean($u:NDEBUG)) then&#xD;
    trace($value,$what)&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:asserterror($errortype as xs:string, $booleanexp as item(), $why as xs:string)  {&#xD;
if(not($booleanexp) and boolean($u:NDEBUG)) then&#xD;
    u:dynamicError(fn:QName('http://www.w3.org/ns/xproc-error',$errortype),$why)&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:assert($booleanexp as item(), $why as xs:string)  {&#xD;
if(not($booleanexp) and boolean($u:NDEBUG)) then &#xD;
    u:dynamicError('err:XC0020',$why)&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:assert($booleanexp as item(), $why as xs:string,$error)  {&#xD;
if(not($booleanexp) and boolean($u:NDEBUG)) then &#xD;
    error(QName('http://www.w3.org/ns/xproc-error',$error),concat("XProc Assert Error: ",$why))&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:boolean($test as xs:string)  {&#xD;
if(contains($test,'false') ) then &#xD;
    false()&#xD;
else&#xD;
    true()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:uuid()  {&#xD;
	util:uuid()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:hash($data,$algorithm)  {&#xD;
	if (contains($algorithm, "md"))then&#xD;
	  util:hash($data, 'md5')&#xD;
	 else&#xD;
 	  util:hash($data,$algorithm)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:unparsed-data($uri as xs:string, $mediatype as xs:string)  {&#xD;
	util:binary-to-string(util:binary-doc($uri))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: TODO: consider combining error throwing functions :)&#xD;
(: consider adding saxon:line-number()  :)&#xD;
declare function u:dynamicError($error,$string) {&#xD;
    let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Dynamic Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:staticError($error,$string) {&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Static Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:stepError($error,$string) {&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Step Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:xprocxqError($error,$string) {&#xD;
let $info := $const:xprocxq-error//xxq-error:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://xproc.net/xproc/error',$error),concat($error,": xprocxq error - ",$string," ",$info/text(),'&amp;#10;'))};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:outputResultElement($exp){&#xD;
    &lt;c:result&gt;{$exp}&lt;/c:result&gt;&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-option($option-name as xs:string,$options,$v){&#xD;
&#xD;
let $option := xs:string($options/*[@name=$option-name]/@select)&#xD;
return&#xD;
	(: TODO - if required this could be an error :)&#xD;
    if (empty($option)) then&#xD;
        ()&#xD;
    (: TODO- need to remove this branch at some point :)&#xD;
    else if(contains($option,"'")) then&#xD;
    	string(replace($option,"'",""))&#xD;
    else&#xD;
    	string(u:evalXPATH(string($option),$v))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-secondary($name as xs:string,$secondary){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
if($secondary/xproc:input[@port=$name]//t:document) then&#xD;
    for $child in $secondary/xproc:input[@port=$name]/t:document/node()&#xD;
    return&#xD;
        document{$child}&#xD;
else&#xD;
    for $child in $secondary/xproc:input[@port=$name]/node()&#xD;
    return&#xD;
        document{$child}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-primary($primary){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if($primary//t:document) then&#xD;
	for $child in $primary/t:document/node()&#xD;
	return&#xD;
		    document{$child}&#xD;
else&#xD;
	for $child in $primary/*&#xD;
	return&#xD;
		    document{$child}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:random() as  xs:double  {&#xD;
   util:random()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:eval($exp as xs:string) as item()*{&#xD;
    util:eval($exp)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: TODO: refactor the following into a single function :)&#xD;
&#xD;
declare function u:call($func,$a) as item()*{&#xD;
    util:call($func,$a)&#xD;
};&#xD;
declare function u:call($func,$a,$b) as item()*{&#xD;
    util:call($func,$a,$b)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c) as item()*{&#xD;
    util:call($func,$a,$b,$c)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d,$e) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d,$e)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d,$e,$f) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d,$e,$f)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(:&#xD;
declare function u:function($func,$arity){&#xD;
    util:function($func, $arity)&#xD;
};&#xD;
:)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query,$xml){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
let $result := util:eval-with-context($qry,$static-content,false())&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query,$xml,$variables){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
                           {for $var in $variables&#xD;
                           return&#xD;
                           &lt;variable name="{$var/@name}"&gt;{$var/node()}&lt;/variable&gt;&#xD;
                           }&#xD;
&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
let $result := util:eval-with-context(fn:concat($const:default-ns-imports,$qry),$static-content,false())&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xsltmatchpattern($match,$xml,$variables){&#xD;
for $item in fn:tokenize($match,'\|')&#xD;
let $declarevars := for $var in $variables&#xD;
                           return&#xD;
                           concat('declare variable ',$var/@name,"",$var/node(),";")&#xD;
let $query := if (starts-with($item, '//')) then&#xD;
    concat($const:default-ns-imports,$declarevars,'.',$item)&#xD;
else if (starts-with($item,'/')) then&#xD;
    concat($const:default-ns-imports,$declarevars,'./',$item)&#xD;
else&#xD;
    concat($const:default-ns-imports,$declarevars,'.//',$item)&#xD;
let $declarens := u:declare-ns($xml)&#xD;
return&#xD;
    util:eval-inline($xml,$query)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery-with-context($query,$xml){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
&#xD;
let $result : = util:eval-inline($xml,$query)&#xD;
&#xD;
(:  let $result := util:eval-with-context($qry,$static-content,false())&#xD;
:)&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery-with-context($query,$xml,$variables){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
                            {for $var in $variables&#xD;
                           return&#xD;
                           &lt;variable name="{$var/@name}"&gt;{$var/node()}&lt;/variable&gt;&#xD;
                           }&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
	let $log-x := util:log("info",$variables)&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
&#xD;
let $result : = util:eval-inline($xml,$query)&#xD;
&#xD;
(:  let $result := util:eval-with-context($qry,$static-content,false())&#xD;
:)&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query as xs:string){&#xD;
    let $qry := if (starts-with($query,'/') or starts-with($query,'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else if($query eq '') then&#xD;
			    u:dynamicError('err:XD0001','query is empty and/or XProc step is not supported')&#xD;
              else&#xD;
                  $query&#xD;
    let $result := util:eval($qry)   &#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xslt($input,$style){&#xD;
    transform:transform($input, document{$style}, ())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:safe-evalXPATH($qry as xs:string, $xml,$pipeline){&#xD;
    util:catch("*",u:evalXPATH($qry, $xml, $pipeline/*),())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:safe-evalXPATH($qry as xs:string, $xml){&#xD;
    util:catch("*", u:evalXPATH($qry,$xml),())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($qry as xs:string, $xml){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
	    util:eval-inline($xml,$query)&#xD;
		(:&#xD;
		if ( $result instance of element() or $result instance of document-node()) then &#xD;
		&#xD;
			u:dynamicError('err:XD0016',$xpathstring)&#xD;
			:)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($qry as xs:string, $xml, $namespaces){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
        let $declarens := u:declare-ns($namespaces)&#xD;
        return&#xD;
	       util:eval-inline($xml,$query)&#xD;
&#xD;
		(:&#xD;
		if ( $result instance of element() or $result instance of document-node()) then&#xD;
			u:dynamicError('err:XD0016',$xpathstring)&#xD;
	    :)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xpathexpression($qry as xs:string, $xml, $namespaces){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
        let $declarens := u:declare-ns($namespaces)&#xD;
        return&#xD;
	       util:eval-inline($xml,$query)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:add-ns-node(&#xD;
    $elem   as element(),&#xD;
    $prefix as xs:string,&#xD;
    $ns-uri as xs:string&#xD;
  ) as element()&#xD;
{&#xD;
  element { QName($ns-uri, concat($prefix, ":x")) }{ $elem }/*&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:deep-equal-seq($primary,$secondary,$strict) {&#xD;
&#xD;
if ($strict eq '1') then&#xD;
let $e1 := (for $child in $primary/*&#xD;
		 return&#xD;
			$child)&#xD;
			&#xD;
let $e2 := (for $child in $secondary/*&#xD;
			return&#xD;
				$child)&#xD;
				&#xD;
return&#xD;
&#xD;
every $i in 1 to max((count($e1),count($e2)))&#xD;
satisfies deep-equal($e1[$i],$e2[$i])&#xD;
&#xD;
&#xD;
else&#xD;
&#xD;
let $e1 := (for $child in $primary/*&#xD;
		 return&#xD;
			u:treewalker($child))&#xD;
			&#xD;
let $e2 := (for $child in $secondary/*&#xD;
			return&#xD;
				u:treewalker($child))&#xD;
				&#xD;
return&#xD;
&#xD;
every $i in 1 to max((count($e1),count($e2)))&#xD;
satisfies deep-equal($e1[$i],$e2[$i])&#xD;
&#xD;
&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:treewalker($element) {&#xD;
element {node-name($element)}&#xD;
   {$element/@*,&#xD;
&#xD;
       for $child in $element/node()&#xD;
           return&#xD;
            if ($child instance of element()) then &#xD;
					u:treewalker($child)&#xD;
              else &#xD;
					normalize-space($child)&#xD;
															&#xD;
   }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:treewalker-add-attribute($element as element(),$match,$attrName,$attrValue) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
       if(name($element) = string($match)) then attribute {$attrName}{$attrValue} else (),&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
               if ($child instance of element())&#xD;
                 then u:treewalker-add-attribute($child,$match,$attrName,$attrValue)&#xD;
                 else $child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:copy-filter-elements($element as element(), $element-name as xs:string*) as element() {&#xD;
   element {node-name($element) }&#xD;
             { $element/@*,&#xD;
               for $child in $element/node()[not(name(.)=$element-name)]&#xD;
                  return if ($child instance of element())&#xD;
                    then u:copy-filter-elements($child,$element-name)&#xD;
                    else $child&#xD;
           }&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:rename-inline-element($element as element(),$match,$newelement) as element() {&#xD;
   element {if(string(node-name($element)) = string($match)) then node-name($newelement) else node-name($element)}&#xD;
      {$element/@*,&#xD;
       if(string(node-name($element)) = $match) then &#xD;
				($newelement/@*)&#xD;
		else &#xD;
			(),&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
               if ($child instance of element())&#xD;
                 then u:rename-inline-element($child,$match,$newelement)&#xD;
                 else $child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:delete-matching-elements($element as element(),$select) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*[not(. intersect $select)],&#xD;
          for $child in $element/node()[not(. intersect $select)]&#xD;
              return                             &#xD;
               if ($child instance of element())&#xD;
                 then &#xD;
                     u:delete-matching-elements($child,$select)&#xD;
                 else&#xD;
                     $child&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:replace-matching-elements($element as element(),$select,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
	    	    		$replace&#xD;
	    	    	else if ($child/text() eq $select ) then&#xD;
	    	    	    element {node-name($child)}{&#xD;
                            $replace&#xD;
 	    	    	    }&#xD;
	    	    	else if ($child/@* intersect $select) then&#xD;
	    	    	    &lt;test/&gt;&#xD;
&#xD;
    			    else&#xD;
                        u:replace-matching-elements($child,$select,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:insert-matching-elements($element as element(),$select,$replace,$position) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
						if($position eq 'before' or $position eq 'first-child') then&#xD;
							($replace,u:insert-matching-elements($child,$select,$replace,$position))&#xD;
						else if($position eq 'after' or $position eq 'last-child') then&#xD;
							(u:insert-matching-elements($child,$select,$replace,$position),$replace)&#xD;
						else	&#xD;
							u:insert-matching-elements($child,$select,$replace,$position)&#xD;
    			    else&#xD;
                        u:insert-matching-elements($child,$select,$replace,$position)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:rename-matching-elements($element as element(),$select,$new-name) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {$new-name}{$child/*&#xD;
						}						&#xD;
    			    else&#xD;
                        u:rename-matching-elements($child,$select,$new-name)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:wrap-matching-elements($element as element(),$select,$wrapper) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {$wrapper}{&#xD;
                        	u:wrap-matching-elements($child,$select,$wrapper)&#xD;
						}						&#xD;
    			    else&#xD;
                        u:wrap-matching-elements($child,$select,$wrapper)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:unwrap-matching-elements($element as element(),$select) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
                        	$child/*&#xD;
    			    else&#xD;
                        u:unwrap-matching-elements($child,$select)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:label-matching-elements($element as element(),$select,$attribute,$label,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{    &#xD;
				        attribute {$attribute} {$label,"_",$pos},&#xD;
                   		u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:label-matching-elements($element as element(),$select,$attribute,$label,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{    &#xD;
				        attribute {$attribute} {$label,"_",$pos},&#xD;
                   		u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:add-attribute-matching-elements($element as element(),$select,$attribute,$label) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {node-name($child)}{&#xD;
				    		$child/@*[not(name(.)=$attribute)],&#xD;
				        	attribute {$attribute} {$label},&#xD;
							if ($child/node() instance of text()) then&#xD;
								$child/text()&#xD;
							else if ($child/node() instance of element()) then						&#xD;
               					u:add-attribute-matching-elements($child,$select,$attribute,$label)&#xD;
							else&#xD;
								$child/*&#xD;
						}	&#xD;
    			    else&#xD;
                        u:add-attribute-matching-elements($child,$select,$attribute,$label)&#xD;
                &#xD;
				else if ($child/node() instance of text()) then&#xD;
                    $child/text()&#xD;
          		else &#xD;
					$child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:add-attributes-matching-elements($element as element(),$select,$attributes) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{&#xD;
				    	$attributes,&#xD;
                   		u:add-attributes-matching-elements($child,$select,$attributes)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:add-attributes-matching-elements($child,$select,$attributes)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:string-replace-matching-elements($element as element(),$select,$replace) as element() {&#xD;
&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element()) then&#xD;
        			if ($child intersect $select) then&#xD;
    	    			(util:log('info','attribute logged'),string($replace))&#xD;
			    	else&#xD;
                    	u:string-replace-matching-elements($child,$select,$replace)&#xD;
                else if ($child instance of attribute()) then&#xD;
        			if ($child intersect $select) then&#xD;
                        (util:log('INFO','***************** attribute logged'),attribute { name($child) } { string($replace) })&#xD;
			    	else&#xD;
                    	u:string-replace-matching-elements($child,$select,$replace)&#xD;
                else&#xD;
                    $child&#xD;
      }&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:treewalker ($tree,$attrFunc,$elemFunc) {&#xD;
&#xD;
  let $children := $tree/*&#xD;
  return&#xD;
      if(empty($children)) then ()&#xD;
      else&#xD;
        for $c in $children&#xD;
            return&#xD;
                ( element {node-name($c)}{&#xD;
                            u:call($attrFunc,$c/@*),&#xD;
                            u:call($elemFunc,$c/*),&#xD;
                        u:treewalker($tree,$attrFunc,$elemFunc)&#xD;
                })&#xD;
};&#xD;
&#xD;
declare function u:treewalker ($tree,$attrFunc,$textFunc,$attName,$attValue) {&#xD;
&#xD;
  let $children := $tree/*&#xD;
  return&#xD;
      if(empty($children)) then ()&#xD;
      else&#xD;
        for $c in $children&#xD;
            return&#xD;
                ( element {node-name($c)}{&#xD;
                            u:call($attrFunc,$c/@*,$attName,$attValue),&#xD;
                            u:call($textFunc,$c/text()),&#xD;
                        u:treewalker($c,$attrFunc,$textFunc,$attName,$attValue)&#xD;
                })&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:attrHandler ($attr,$attName,$attValue) {&#xD;
	$attr, attribute {string($attName)}{string($attValue)}&#xD;
 };&#xD;
&#xD;
declare function u:textHandler ($text) {&#xD;
	$text&#xD;
 };&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:declare-used-namespaces ( $root as node()? )  as xs:anyURI* {&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
return &#xD;
    let $ns := concat('ns',$pos)&#xD;
    return&#xD;
        util:declare-namespace($ns,$namespace)&#xD;
} ;&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:list-used-namespaces1 ( $root as node()? )  {&#xD;
let $prefix :=   (distinct-values($root/descendant-or-self::*/(.|@*)/substring-before(name(.), ':')) )&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
	return &#xD;
	 if ($namespace eq 'http://www.w3.org/XML/1998/namespace') then&#xD;
		()&#xD;
	 else if ($namespace eq 'http://www.w3.org/ns/xproc-step') then&#xD;
		()&#xD;
&#xD;
	 else&#xD;
		let $ns := $prefix[$pos]&#xD;
    			return&#xD;
         			concat('declare namespace ',$ns,'="',$namespace,'";')&#xD;
} ;&#xD;
&#xD;
 declare function u:list-used-namespaces ( $root as node()? )  as xs:string* {&#xD;
let $prefix :=   (distinct-values($root/descendant-or-self::*/(.|@*)/substring-before(name(.), ':')) )&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
    return &#xD;
        &#xD;
		let $ns := $prefix[$pos - 1]&#xD;
    			return&#xD;
            if ($namespace eq '') then&#xD;
                ()&#xD;
			else if ($namespace eq 'http://www.w3.org/XML/1998/namespace') then&#xD;
				()&#xD;
            else if ($ns) then 	&#xD;
       			concat('declare namespace ',$ns,'="',$namespace,'";')&#xD;
            else&#xD;
                concat('declare default element namespace "',$namespace,'";')&#xD;
} ;&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:validate($exp) as xs:string {&#xD;
$exp&#xD;
(:&#xD;
    nvdl:main("file:test/data/w3schema.xml file:test/data/schema-example.xml")&#xD;
:)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:serialize($xml,$options){&#xD;
	util:serialize($xml,$options)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:parse-string($string) as item()*{&#xD;
    util:parse($string)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:map($func, $seqA as item()*, $seqB as item()*) &#xD;
as item()* {&#xD;
	if(count($seqA) != count($seqB)) then ()&#xD;
	else&#xD;
    	for $a at $i in $seqA&#xD;
    	let $b := $seqB[$i]&#xD;
    	return&#xD;
        	u:call($func, $a, $b)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:filter($func, $seq as item()*) &#xD;
as item()* {&#xD;
	for $i in $seq&#xD;
	return&#xD;
		if(u:call($func, $i)) then&#xD;
			$i&#xD;
		else&#xD;
			()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: test folding the step with a different function :)&#xD;
declare function u:printstep ($step,$meta,$value) {&#xD;
    u:call( $step, $value)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:strip-namespace($e as element()) as element() {&#xD;
  &#xD;
   element {QName((),local-name($e))} {&#xD;
    for $child in $e/(@*,node())&#xD;
    return&#xD;
      if ($child instance of element())&#xD;
      then&#xD;
        u:strip-namespace($child)&#xD;
      else&#xD;
        $child&#xD;
  }&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:uniqueid($unique_id,$count){&#xD;
    concat($unique_id,'.',$count)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:final-result($pipeline,$resulttree){&#xD;
    ($pipeline,$resulttree)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:step-fold( $pipeline,&#xD;
                              $namespaces,&#xD;
                              $steps,&#xD;
                              $evalstep-function,&#xD;
                              $primary,&#xD;
                              $outputs) {&#xD;
&#xD;
    if (empty($steps)) then&#xD;
        u:final-result($pipeline,$outputs)&#xD;
&#xD;
    else&#xD;
        let $result:= u:call($evalstep-function,&#xD;
                                $steps[1],&#xD;
                                $namespaces,&#xD;
                                $primary,&#xD;
                                $pipeline,&#xD;
                                $outputs)&#xD;
    return&#xD;
        u:step-fold($pipeline,&#xD;
                    $namespaces,&#xD;
                    remove($steps, 1),&#xD;
                    $evalstep-function,&#xD;
                    $result[last()],&#xD;
                    ($outputs,$result))&#xD;
};&#xD;
&#xD;
&#xD;
:)&#xD;
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><div><textarea rows="20" cols="100"><doc:xqdoc xmlns:doc="http://www.xqdoc.org/1.0"><doc:control><!--Generated by xquerydoc: http://github.com/xquery/xquerydoc--><doc:date>2011-11-20T18:23:55.157+01:00</doc:date><doc:version>N/A</doc:version></doc:control><doc:module type="library"><doc:uri>http://xproc.net/xproc/util</doc:uri></doc:module><doc:variables><doc:variable><doc:uri>NDEBUG</doc:uri></doc:variable></doc:variables><doc:functions><doc:function><doc:name>declarens</doc:name><doc:signature>($element)</doc:signature><doc:parameters><doc:parameter><doc:name/></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>declare-ns</doc:name><doc:signature>($namespaces)</doc:signature><doc:parameters><doc:parameter><doc:name>namespaces</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>enum-ns</doc:name><doc:signature>($element)</doc:signature><doc:parameters><doc:parameter><doc:name/></doc:parameter></doc:parameters></doc:function></doc:functions></doc:xqdoc></textarea></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>