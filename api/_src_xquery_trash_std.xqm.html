<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div id="main"><h1><span class="namespace"/>  library module </h1><div id="variables"><h3>Variables</h3></div><div id="functions"><h3>Functions</h3></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">xquery version "1.0" encoding "UTF-8";&#xD;
module namespace std = "http://xproc.net/xproc/std";&#xD;
(: ------------------------------------------------------------------------------------- &#xD;
&#xD;
	std.xqm - Implements all standard xproc steps.&#xD;
	&#xD;
---------------------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
(: XProc Namespace Declaration :)&#xD;
declare namespace p="http://www.w3.org/ns/xproc";&#xD;
declare namespace c="http://www.w3.org/ns/xproc-step";&#xD;
declare namespace err="http://www.w3.org/ns/xproc-error";&#xD;
declare namespace xsl="http://www.w3.org/1999/XSL/Transform";&#xD;
declare namespace xproc = "http://xproc.net/xproc";&#xD;
&#xD;
declare namespace t = "http://xproc.org/ns/testsuite";&#xD;
&#xD;
&#xD;
(: Module Imports :)&#xD;
import module namespace u = "http://xproc.net/xproc/util" at "resource:net/xproc/xprocxq/src/xquery/util.xqm";&#xD;
import module namespace const = "http://xproc.net/xproc/const" at "resource:net/xproc/xprocxq/src/xquery/const.xqm";&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
(: Module Vars :)&#xD;
declare variable $std:add-attribute :=util:function(xs:QName("std:add-attribute"), 4);&#xD;
declare variable $std:add-xml-base :=util:function(xs:QName("std:add-xml-base"), 4);&#xD;
declare variable $std:count :=util:function(xs:QName("std:count"), 4);&#xD;
declare variable $std:compare :=util:function(xs:QName("std:compare"),4);&#xD;
declare variable $std:delete :=util:function(xs:QName("std:delete"),4);&#xD;
declare variable $std:error :=util:function(xs:QName("std:error"), 4);&#xD;
declare variable $std:filter :=util:function(xs:QName("std:filter"), 4);&#xD;
declare variable $std:directory-list :=util:function(xs:QName("std:directory-list"), 4);&#xD;
declare variable $std:escape-markup :=util:function(xs:QName("std:escape-markup"), 4);&#xD;
declare variable $std:http-request :=util:function(xs:QName("std:http-request"), 4);&#xD;
declare variable $std:identity :=util:function(xs:QName("std:identity"), 4);&#xD;
declare variable $std:insert :=util:function(xs:QName("std:insert"), 4);&#xD;
declare variable $std:label-elements :=util:function(xs:QName("std:label-elements"), 4);&#xD;
declare variable $std:load :=util:function(xs:QName("std:load"), 4);&#xD;
declare variable $std:make-absolute-uris :=util:function(xs:QName("std:make-absolute-uris"), 4);&#xD;
declare variable $std:namespace-rename :=util:function(xs:QName("std:namespace-rename"), 4);&#xD;
declare variable $std:pack :=util:function(xs:QName("std:pack"), 4);&#xD;
declare variable $std:parameters :=util:function(xs:QName("std:parameters"), 4);&#xD;
declare variable $std:rename :=util:function(xs:QName("std:rename"), 4);&#xD;
declare variable $std:replace :=util:function(xs:QName("std:replace"), 4);&#xD;
declare variable $std:set-attributes :=util:function(xs:QName("std:set-attributes"), 4);&#xD;
declare variable $std:sink :=util:function(xs:QName("std:sink"), 4);&#xD;
declare variable $std:split-sequence :=util:function(xs:QName("std:split-sequence"), 4);&#xD;
declare variable $std:store :=util:function(xs:QName("std:store"), 4);&#xD;
declare variable $std:string-replace :=util:function(xs:QName("std:string-replace"), 4);&#xD;
declare variable $std:unescape-markup :=util:function(xs:QName("std:unescape-markup"), 4);&#xD;
declare variable $std:xinclude :=util:function(xs:QName("std:xinclude"), 4);&#xD;
declare variable $std:wrap :=util:function(xs:QName("std:wrap"), 4);&#xD;
declare variable $std:wrap-sequence :=util:function(xs:QName("std:wrap-sequence"), 4);&#xD;
declare variable $std:unwrap :=util:function(xs:QName("std:unwrap"), 4);&#xD;
declare variable $std:xslt :=util:function(xs:QName("std:xslt"), 4);&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:add-attribute($primary,$secondary,$options,$variables) {&#xD;
&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $attribute-name := u:get-option('attribute-name',$options,$v)&#xD;
let $checkname := u:asserterror('err:XC0059', boolean($attribute-name ne 'xmlns'), 'This step cannot be used to add namespace declarations')&#xD;
let $attribute-value := u:get-option('attribute-value',$options,$v)&#xD;
let $attribute-prefix := u:get-option('attribute-prefix',$options,$v)&#xD;
let $attribute-namespace := u:get-option('attribute-namespace',$options,$v)&#xD;
let $ifnamespacedeclared := if ($attribute-namespace ne '') then&#xD;
util:declare-namespace($attribute-prefix, $attribute-namespace)&#xD;
else&#xD;
 ()&#xD;
&#xD;
let $attrname  := if ($attribute-namespace ne '') then&#xD;
fn:QName($attribute-namespace,$attribute-name)&#xD;
else&#xD;
 $attribute-name&#xD;
&#xD;
return&#xD;
&#xD;
	u:add-attribute-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$attrname,$attribute-value)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:add-xml-base($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $all := u:get-option('all',$options,$v)&#xD;
let $relative := u:get-option('relative',$options,$v)&#xD;
let $matchresult := u:evalXPATH('//*', $v, $primary)&#xD;
let $attribute-name := "xml:base"&#xD;
let $attribute-value := base-uri($v)&#xD;
return&#xD;
	u:add-attribute-matching-elements($v,x,$attribute-name,$attribute-value)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:compare($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $alternate : = u:get-secondary('alternate',$secondary)&#xD;
let $strict := xs:boolean(u:get-option('xproc:strict',$options,$v)) (: ext attribute xproc:strict:)&#xD;
let $fail-if-not-equal := xs:boolean(u:get-option('fail-if-not-equal',$options,$v))&#xD;
&#xD;
let $result :=  if ($strict and count($v/*) eq 1) then&#xD;
		deep-equal($v,$alternate)&#xD;
&#xD;
else if ($strict and count($v/*) gt 1) then&#xD;
	u:deep-equal-seq($v,$alternate,'1')&#xD;
&#xD;
else if (count($v/*) gt 1) then&#xD;
	u:deep-equal-seq($v,$alternate,'0')&#xD;
&#xD;
else &#xD;
	deep-equal(u:treewalker($v/*),u:treewalker($alternate/*))&#xD;
&#xD;
    return&#xD;
&#xD;
       if($fail-if-not-equal) then&#xD;
            if ($result) then          &#xD;
      			u:outputResultElement('true')&#xD;
            else&#xD;
                u:stepError('err:XC0019','p:compare fail-if-not-equal option is enabled and documents were not equal')&#xD;
        else&#xD;
            u:outputResultElement($result)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:count($primary,$secondary,$options,$variables){&#xD;
let $v := u:get-primary($primary)&#xD;
let $limit := xs:integer(u:get-option('limit',$options,$v))&#xD;
let $count := count($v/*)&#xD;
return&#xD;
    if (empty($limit) or $limit eq 0 or $count lt $limit ) then&#xD;
		u:outputResultElement($count)&#xD;
    else if (empty($v)) then&#xD;
   		u:outputResultElement(0)&#xD;
    else&#xD;
   		u:outputResultElement($limit)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:delete($primary,$secondary,$options,$variables){&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
return&#xD;
   	u:delete-matching-elements($v/*,  u:xsltmatchpattern($match,$v,$variables) )&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:directory-list($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $path := u:get-option('path',$options,$v)&#xD;
let $include-filter := u:get-option('include-filter',$options,$v)&#xD;
let $exclude-filter := u:get-option('exclude-filter',$options,$v)&#xD;
&#xD;
let $segment := substring-after($path,'file://')&#xD;
let $dirname := tokenize($path, '/')[last()]&#xD;
let $result := if (starts-with($path,'file://')) then&#xD;
                let $query := concat("file:directory-list('",$segment,"','",$include-filter,"')")&#xD;
                let $files := u:eval($query)&#xD;
                return&#xD;
                    &lt;c:directory name="{$dirname}"&gt;&#xD;
					{for $file in $files//*:file&#xD;
					return&#xD;
						&lt;c:file name="{$file/@name}"/&gt;&#xD;
					}&#xD;
				    &lt;/c:directory&gt;&#xD;
              else&#xD;
                let $files := collection($path)/util:document-name(.)&#xD;
                return&#xD;
                    &lt;c:directory name="{$dirname}"&gt;&#xD;
					{for $file in $files&#xD;
					return&#xD;
						&lt;c:file name="{$file}"/&gt;&#xD;
					}&#xD;
				    &lt;/c:directory&gt;&#xD;
				    (: TODO: throw err:XC0017 if no directory exists :)&#xD;
return&#xD;
		u:outputResultElement($result)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:escape-markup($primary,$secondary,$options,$variables) {&#xD;
(: TODO: test with sequences :)&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
	element{name($v/*)}{&#xD;
    	u:serialize($v/*/*,$const:ESCAPE_SERIALIZE)&#xD;
	}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:error($primary,$secondary,$options,$variables) {&#xD;
(: TODO: this should be generated to the error port:)&#xD;
&#xD;
let $v := u:get-primary($primary)&#xD;
let $code := u:get-option('code',$options,$v)&#xD;
let $err := &lt;c:errors xmlns:c="http://www.w3.org/ns/xproc-step"&#xD;
          xmlns:p="http://www.w3.org/ns/xproc"&#xD;
          xmlns:my="http://www.example.org/error"&gt;&#xD;
		&lt;c:error href="" column="" offset=""&#xD;
         	name="step-name" type="p:error"&#xD;
         	code="{$code}"&gt;&#xD;
    		&lt;message&gt;{$v}&lt;/message&gt;&#xD;
		&lt;/c:error&gt;&#xD;
&lt;/c:errors&gt;&#xD;
return&#xD;
	u:dynamicError('err:XD0030',concat(": p:error throw custom error code - ",$code," ",u:serialize($err,$const:TRACE_SERIALIZE)))&#xD;
&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:filter($primary,$secondary,$options,$variables) {&#xD;
(: TODO - broken :)&#xD;
u:assert(exists($options/p:with-option[@name='select']/@select),'p:with-option match is required'),&#xD;
let $v := u:get-primary($primary)&#xD;
let $select := string(u:get-option('select',$options,$v))&#xD;
let $result := u:evalXPATH($select,document{$v},$primary)&#xD;
    return&#xD;
        if(exists($result)) then&#xD;
        	$result&#xD;
		else&#xD;
            ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:http-request($primary,$secondary,$options,$variables) {&#xD;
    let $v := u:get-primary($primary)&#xD;
    let $href := $v/c:request/@href&#xD;
    let $method := $v/c:request/@method&#xD;
    let $content-type := $v/c:request/c:body/@content-type&#xD;
    let $body := $v/c:request/c:body&#xD;
    let $status-only := $v/c:request/@status-only&#xD;
    let $detailed := $v/c:request/@detailed&#xD;
    let $username := ''&#xD;
    let $password := ''&#xD;
    let $auth-method := ''&#xD;
    let $send-authorization := ''&#xD;
    let $override-content-type := ''&#xD;
    let $follow-redirect := ''&#xD;
    let $http-request := &lt;http:request href="{$href}" method="{$method}"&gt;{&#xD;
            for $header in $v/c:request/c:header&#xD;
            return&#xD;
                &lt;http:header name="{$header/@name}" value="{$header/@value}"/&gt;,&#xD;
&#xD;
            if (empty($body)) then&#xD;
                ()&#xD;
            else&#xD;
              &lt;http:body content-type="{$content-type}"&gt;&#xD;
                 {$body}&#xD;
              &lt;/http:body&gt;&#xD;
        }&#xD;
           &lt;/http:request&gt;&#xD;
    let $raw-response := () (: http:send-request($http-request) :)&#xD;
    let $response-headers := for $header in $raw-response//http:header&#xD;
            return&#xD;
                &lt;c:header name="{$header/@name}" value="{$header/@value}"/&gt;&#xD;
&#xD;
    let $response-body := if ($status-only) then&#xD;
            ()&#xD;
         else if ($detailed) then&#xD;
            &lt;c:body&gt;{$raw-response/*[not(name(.) eq 'http:body')][not(name(.) eq 'http:header')]}&lt;/c:body&gt;&#xD;
         else&#xD;
            $raw-response/*[not(name(.) eq 'http:body')][not(name(.) eq 'http:header')]&#xD;
&#xD;
    return&#xD;
&#xD;
        if (not($v/c:request)) then&#xD;
                u:dynamicError('err:XC0040',"source port must contain c:request element")&#xD;
        else if ($detailed) then&#xD;
          &lt;c:response status="{$raw-response/@status}"&gt;&#xD;
            {$response-headers}&#xD;
            {$response-body}&#xD;
          &lt;/c:response&gt;&#xD;
        else&#xD;
            $response-body&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:identity($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
	$v&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:insert($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $position := u:get-option('position',$options,$v)&#xD;
let $insertion := u:get-secondary('insertion',$secondary)&#xD;
return&#xD;
	u:insert-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$insertion,$position)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:label-elements($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $attribute := u:get-option('attribute',$options,$v)&#xD;
let $label := u:get-option('label',$options,$v)&#xD;
let $replace := u:get-option('replace',$options,$v)&#xD;
return&#xD;
	u:label-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$attribute,$label,$replace)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:load($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $href := u:get-option('href',$options,$v)&#xD;
let $xproc:output-uri := u:get-option('xproc:output-uri',$options,$v)&#xD;
return&#xD;
if (empty($href)) then&#xD;
	u:dynamicError('err:XC0026',"p:load option href is empty.")&#xD;
else if(starts-with($href,'file://')) then&#xD;
		let $test-exists := concat("file:exists('",&#xD;
									 substring-after($href,'file://'),&#xD;
									 "')")&#xD;
		let $query := concat("file:read('",&#xD;
									 $href,&#xD;
									 "')")			&#xD;
		return&#xD;
			if (u:eval($test-exists)) then&#xD;
				u:parse-string(u:eval($query))&#xD;
			else&#xD;
				u:dynamicError('err:XC0026',"p:load could not access or find the file.")			&#xD;
else&#xD;
	let $load := doc($href)&#xD;
	return&#xD;
		if ($xproc:output-uri eq 'true') then&#xD;
			u:outputResultElement($href)&#xD;
		else&#xD;
			$load&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:make-absolute-uris($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
	$v&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:namespace-rename($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
	$v&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:pack($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $alternate := u:get-secondary('alternate',$secondary)&#xD;
let $wrapper := u:get-option('wrapper',$options,$v)&#xD;
return&#xD;
&#xD;
    for $child at $count in $v&#xD;
    return&#xD;
	    element {$wrapper}{&#xD;
	        $child,&#xD;
	        $alternate&#xD;
	    }&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:parameters($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
	$v&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:rename($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $new-name := u:get-option('new-name',$options,$v)&#xD;
return&#xD;
	u:rename-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$new-name)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:replace($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $replacement := u:get-secondary('replacement',$secondary)&#xD;
return&#xD;
	u:replace-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$replacement)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:set-attributes($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $attributes := u:get-secondary('attributes',$secondary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
return&#xD;
	u:add-attributes-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$attributes/*/@*)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:sink($primary,$secondary,$options,$variables) {&#xD;
    (string(''))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:split-sequence($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $test := u:get-option('test',$options,$v)&#xD;
let $match := u:evalXPATH($test, $v, $primary)&#xD;
return&#xD;
    for $child at $count in $match&#xD;
    return&#xD;
        if($child) then&#xD;
            $v[$count]&#xD;
        else&#xD;
            ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:store($primary,$secondary,$options,$variables) {&#xD;
(:TODO - check existence of collection path :)&#xD;
let $v := u:get-primary($primary)&#xD;
let $href-uri := u:get-option('href',$options,$v)&#xD;
let $name := tokenize($href-uri, "/")[last()]&#xD;
let $xproc:output-document := u:get-option('xproc:output-document',$options,$v)&#xD;
let $path := substring-before($href-uri,$name)&#xD;
let $serialized := u:serialize($v,$const:DEFAULT_SERIALIZE)&#xD;
let $store := if(starts-with($path,'file://')) then&#xD;
				let $query := concat("file:serialize(",&#xD;
									 $serialized,&#xD;
								 	 ",'",&#xD;
									 substring-after($href-uri,'file://'),&#xD;
									 "','method=xml')")&#xD;
				return&#xD;
					u:eval($query) &#xD;
			  else&#xD;
								xmldb:store($path,$name,$v)&#xD;
return&#xD;
if($xproc:output-document eq 'true') then&#xD;
		$v&#xD;
	else&#xD;
		u:outputResultElement(concat($path,$name))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:string-replace($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $replace := string(u:get-option('replace',$options,$v))&#xD;
return&#xD;
    util:catch('*',u:string-replace-matching-elements($v, u:xsltmatchpattern($match,$v,$variables),$replace),u:dynamicError("err:XD0001",": p:string-replace resulted in non xml output"))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:unescape-markup($primary,$secondary,$options,$variables){&#xD;
(: TODO: test with sequences :)&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
    element{name($v/*)}{&#xD;
		u:parse-string($v)&#xD;
		}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:xinclude($primary,$secondary,$options,$variables){&#xD;
let $v := u:get-primary($primary)&#xD;
return&#xD;
	u:parse-string(u:serialize($v,'expand-xincludes=yes'))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:wrap($primary,$secondary,$options,$variables) {&#xD;
let $v := u:get-primary($primary)&#xD;
let $match := u:get-option('match',$options,$v)&#xD;
let $wrapper := u:get-option('wrapper',$options,$v)&#xD;
let $group-adjacent := u:get-option('group-adjacent',$options,$v)&#xD;
return&#xD;
    if ($match eq '/') then&#xD;
        element {$wrapper}{&#xD;
	    	$v&#xD;
	    }&#xD;
	else&#xD;
	    u:wrap-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables),$wrapper)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:wrap-sequence($primary,$secondary,$options,$variables){&#xD;
let $v := u:get-primary($primary)&#xD;
let $wrapper := u:get-option('wrapper',$options,$v)&#xD;
let $group-adjacent := u:get-option('group-adjacent',$options,$v)&#xD;
return&#xD;
	element {$wrapper}{&#xD;
		$v&#xD;
	}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:unwrap($primary,$secondary,$options,$variables) {&#xD;
    let $v := u:get-primary($primary)&#xD;
    let $match := u:get-option('match',$options,$v)&#xD;
    return&#xD;
        u:unwrap-matching-elements($v/*, u:xsltmatchpattern($match,$v,$variables))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function std:xslt($primary,$secondary,$options,$variables){&#xD;
	let $v := u:get-primary($primary)&#xD;
    let $stylesheet := u:get-secondary('stylesheet',$secondary)&#xD;
    return&#xD;
        u:xslt(document{$v},document{$stylesheet})&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>