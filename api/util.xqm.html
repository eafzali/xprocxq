<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><meta http-equiv="Authors" content="Copyright 2011 - John Snelson, James Fuller"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div style="text-align:right;"><a href="index.html">XQuery API index</a></div><div id="main"><h1><span class="namespace"/>  library module </h1><div><h3>Variables</h3><ul><li>NDEBUG</li></ul></div><div><h3>Functions</h3><h4><pre class="prettyprint lang-xq"><u>Function:</u> store($href as xs:string,$data as item())</pre></h4><h5>Params</h5><ul><li>href:  xs:string</li><li>data:  item()</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> parse($data as xs:string) as  item()</pre></h4><h5>Params</h5><ul><li>data:  xs:string</li></ul><h5>Returns</h5><ul><li>:  item()</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> serialize($xml) as  xs:string</pre></h4><h5>Params</h5><ul><li>xml: </li></ul><h5>Returns</h5><ul><li>:  xs:string</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> dirlist($path)</pre></h4><h5>Params</h5><ul><li>path: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> evalXPATH($xpath, $xml)</pre></h4><h5>Params</h5><ul><li>xpath: </li><li>xml: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> transform($stylesheet,$xml)</pre></h4><h5>Params</h5><ul><li>stylesheet: </li><li>xml: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> xsltMatchPattern($xpath,$node)</pre></h4><h5>Params</h5><ul><li>xpath: </li><li>: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> outputResultElement($exp)</pre></h4><h5>Params</h5><ul><li>exp: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> get-secondary($name as xs:string,$secondary as element(xproc:input)*) as  item()*</pre></h4><h5>Params</h5><ul><li>name:  xs:string</li><li>secondary:  element(xproc:input)</li></ul><h5>Returns</h5><ul><li>:  item()</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> get-option($option-name as xs:string,$options as element(xproc:options),$primary) as  xs:string*</pre></h4><h5>Params</h5><ul><li>option-name:  xs:string</li><li>options:  element(xproc:options)</li><li>primary: </li></ul><h5>Returns</h5><ul><li>:  xs:string</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> result-document($href as xs:string, $doc as item())</pre></h4><h5>Params</h5><ul><li>href:  xs:string</li><li>doc:  item()</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> dynamicError($error,$string)</pre></h4><h5>Params</h5><ul><li>error: </li><li>string: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> stepError($error,$string)</pre></h4><h5>Params</h5><ul><li>error: </li><li>string: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> binary-doc($uri)</pre></h4><h5>Params</h5><ul><li>uri: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> binary-to-string($data)</pre></h4><h5>Params</h5><ul><li>data: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> serialize($xml,$options)</pre></h4><h5>Params</h5><ul><li>xml: </li><li>options: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> trace($value as item()*, $what as xs:string)</pre></h4><h5>Params</h5><ul><li>value:  item()</li><li>what:  xs:string</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> asserterror($errortype as xs:string, $booleanexp as item(), $why as xs:string)</pre></h4><h5>Params</h5><ul><li>errortype:  xs:string</li><li>booleanexp:  item()</li><li>why:  xs:string</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> assert($booleanexp as item(), $why as xs:string)</pre></h4><h5>Params</h5><ul><li>booleanexp:  item()</li><li>why:  xs:string</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> assert($booleanexp as item(), $why as xs:string,$error)</pre></h4><h5>Params</h5><ul><li>booleanexp:  item()</li><li>why:  xs:string</li><li>error: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> declarens($element)</pre></h4><h5>Params</h5><ul><li>: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> declare-ns($namespaces)</pre></h4><h5>Params</h5><ul><li>namespaces: </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> namespaces-in-use( $root as node()?)</pre></h4><h5>Params</h5><ul><li>root:  node()</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> enum-ns($element)</pre></h4><h5>Params</h5><ul><li>: </li></ul></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">(: ------------------------------------------------------------------------------------- &#xD;
 &#xD;
	util.xqm - contains most of the XQuery processor specific functions, including all&#xD;
	helper functions.&#xD;
	&#xD;
---------------------------------------------------------------------------------------- :)&#xD;
xquery version "3.0" encoding "UTF-8";&#xD;
&#xD;
module namespace u = "http://xproc.net/xproc/util";&#xD;
&#xD;
(: declare namespaces :)&#xD;
declare namespace p="http://www.w3.org/ns/xproc";&#xD;
declare namespace c="http://www.w3.org/ns/xproc-step";&#xD;
declare namespace err="http://www.w3.org/ns/xproc-error";&#xD;
declare namespace xsl="http://www.w3.org/1999/XSL/Transform";&#xD;
declare namespace xproc = "http://xproc.net/xproc";&#xD;
declare namespace std = "http://xproc.net/xproc/std";&#xD;
declare namespace opt = "http://xproc.net/xproc/opt";&#xD;
declare namespace ext = "http://xproc.net/xproc/ext";&#xD;
declare namespace xxq-error = "http://xproc.net/xproc/error";&#xD;
&#xD;
&#xD;
(: Module Imports :)&#xD;
import module namespace const = "http://xproc.net/xproc/const" at "const.xqm";&#xD;
&#xD;
&#xD;
(: set to 1 to enable debugging :)&#xD;
declare variable $u:NDEBUG :=$const:NDEBUG;&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:store($href as xs:string,$data as item()){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $result := saxon:result-document($href, $data, &lt;xsl:output method="xml"/&gt;)&#xD;
return&#xD;
  $href&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:parse($data as xs:string) as item(){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
saxon:parse($data) &#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:serialize($xml) as xs:string{&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
saxon:serialize($xml, &lt;xsl:output method="xml" &#xD;
                             omit-xml-declaration="yes" &#xD;
                             indent="yes" &#xD;
                             saxon:indent-spaces="1"/&gt;) &#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:dirlist($path){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
collection(concat($path,"?select=*.*;recurse=yes;on-error=ignore"))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($xpath, $xml){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
  if ($xpath eq '/' or $xpath eq '' or empty($xml)) then&#xD;
    $xml&#xD;
  else&#xD;
    ($xml/.)/saxon:evaluate($xpath)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:transform($stylesheet,$xml){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
  let $rendition := saxon:compile-stylesheet(document{$stylesheet})&#xD;
  return&#xD;
    saxon:transform($rendition, $xml)&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xsltMatchPattern($xpath,$node){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $match := document {&lt;xsl:stylesheet version="2.0"&gt;&#xD;
&lt;xsl:template match="{$xpath}"&gt;&#xD;
    &lt;xsl:apply-templates mode="m"/&gt;&#xD;
&lt;/xsl:template&gt;&#xD;
&#xD;
&lt;xsl:template match="@*|node()" mode="m"&gt;&#xD;
    &lt;xsl:copy&gt;&#xD;
        &lt;xsl:apply-templates select="@*|node()" mode="m"/&gt;&#xD;
    &lt;/xsl:copy&gt;&#xD;
&lt;/xsl:template&gt;&#xD;
&#xD;
&lt;xsl:template match="text()"/&gt;&#xD;
&#xD;
&lt;/xsl:stylesheet&gt;}        &#xD;
let $rendition := saxon:compile-stylesheet($match)&#xD;
return&#xD;
  saxon:transform($rendition, $node)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:outputResultElement($exp){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    &lt;c:result&gt;{$exp}&lt;/c:result&gt;&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-secondary($name as xs:string,$secondary as element(xproc:input)*) as item()*{&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    $secondary[@port eq $name]/node() &#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-option($option-name as xs:string,$options as element(xproc:options),$primary) as xs:string*{&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $value as xs:string := replace(string($options//p:with-option[@name eq $option-name]/@select),'&amp;quot;','')&#xD;
return&#xD;
  $value&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: PRIMARY UTILITIES                                                          :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:result-document($href as xs:string, $doc as item()){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $writelog :=  saxon:result-document($href, $doc, &lt;xsl:output method="xml" indent="yes"/&gt;)&#xD;
return&#xD;
  $href&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:dynamicError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Dynamic Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:stepError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Step Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:binary-doc($uri){&#xD;
()&#xD;
};&#xD;
&#xD;
declare function u:binary-to-string($data){&#xD;
()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:serialize($xml,$options){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
$xml&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: ASSERTIONS, DEBUG TOOLS                                                    :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:trace($value as item()*, $what as xs:string)  {&#xD;
if(boolean($const:NDEBUG)) then&#xD;
    trace($value,$what)&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:asserterror($errortype as xs:string, $booleanexp as item(), $why as xs:string)  {&#xD;
if(not($booleanexp) and boolean($const:NDEBUG)) then&#xD;
    u:dynamicError(fn:QName('http://www.w3.org/ns/xproc-error',$errortype),$why)&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:assert($booleanexp as item(), $why as xs:string)  {&#xD;
if(not($booleanexp) and boolean($const:NDEBUG)) then &#xD;
    u:dynamicError('err:XC0020',$why)&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:assert($booleanexp as item(), $why as xs:string,$error)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if(not($booleanexp) and boolean($u:NDEBUG)) then &#xD;
    error(QName('http://www.w3.org/ns/xproc-error',$error),concat("XProc Assert Error: ",$why))&#xD;
else&#xD;
    ()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: manage namespaces                                                          :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:declarens($element){&#xD;
    u:declare-ns(u:enum-ns($element))&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:declare-ns($namespaces){&#xD;
    for $ns in $namespaces//ns&#xD;
    return&#xD;
        ()&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:namespaces-in-use( $root as node()? )  {&#xD;
       &#xD;
for $ns in distinct-values(&#xD;
      $root/descendant-or-self::*/(.)/in-scope-prefixes(.))&#xD;
&#xD;
return&#xD;
  &lt;ns prefix="{$ns}" URI="{namespace-uri-for-prefix($ns,$root)}"/&gt;&#xD;
&#xD;
 } ;&#xD;
&#xD;
declare function u:enum-ns($element){&#xD;
       for $child in $element/node()&#xD;
            return&#xD;
              if ($child instance of element() or $child instance of document-node()) then&#xD;
               	 u:namespaces-in-use($child)&#xD;
                else&#xD;
                  &lt;ns/&gt;&#xD;
&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: DEPRECATED &#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: generate unique id														  :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:uniqueid($unique_id,$count) as xs:string{&#xD;
    concat($unique_id,'.',$count)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns comp from comp definitions :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-comp($compname as xs:string) {&#xD;
    $const:comp-steps//xproc:element[@type=$compname]&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: checks to see if this component exists :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:comp-available($compname as xs:string) as xs:boolean {&#xD;
        exists(u:get-comp($compname))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns step from std, opt and ext step definitions :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-step($stepname as xs:string,$declarestep) {&#xD;
    $const:std-steps/p:declare-step[@type=$stepname],&#xD;
    $const:opt-steps/p:declare-step[@type=$stepname],&#xD;
    $const:ext-steps/p:declare-step[@type=$stepname],&#xD;
    $const:comp-steps//xproc:element[@type=$stepname], &#xD;
    $declarestep/@type&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns step type :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:type($stepname as xs:string,$is_declare-step) as xs:string {&#xD;
&#xD;
    let $stdstep := $const:std-steps/p:declare-step[@type=$stepname]&#xD;
    let $optstep := $const:opt-steps/p:declare-step[@type=$stepname]&#xD;
    let $extstep := $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
    let $component :=$const:comp-steps//xproc:element[@type=$stepname]&#xD;
&#xD;
    let $stdstepexists := exists($stdstep)&#xD;
    let $optstepexists := exists($optstep)&#xD;
    let $extstepexists := exists($extstep)&#xD;
    let $compexists := exists($component)&#xD;
    return&#xD;
        if ($optstepexists) then&#xD;
            'opt'&#xD;
        else if($extstepexists) then&#xD;
            'ext'&#xD;
        else if($stdstepexists) then&#xD;
            'std'&#xD;
        else if($compexists) then&#xD;
            'comp'&#xD;
        else if($is_declare-step) then&#xD;
          string(substring-before($is_declare-step/@type,':'))&#xD;
        else&#xD;
          u:staticError('err:XS0044', concat($stepname,":",$stepname,' has no visible declaration'))&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:boolean($test as xs:string)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if(contains($test,'false') ) then &#xD;
    false()&#xD;
else&#xD;
    true()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:uuid()  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
	util:uuid()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:hash($data,$algorithm)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
	if (contains($algorithm, "md"))then&#xD;
	  util:hash($data, 'md5')&#xD;
	 else&#xD;
 	  util:hash($data,$algorithm)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:unparsed-data($uri as xs:string, $mediatype as xs:string)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
	util:binary-to-string(util:binary-doc($uri))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: TODO: consider combining error throwing functions :)&#xD;
(: consider adding saxon:line-number()  :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:dynamicError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Dynamic Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:staticError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Static Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:stepError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Step Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xprocxqError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:xprocxq-error//xxq-error:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://xproc.net/xproc/error',$error),concat($error,": xprocxq error - ",$string," ",$info/text(),'&amp;#10;'))};&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-secondary($name as xs:string,$secondary){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
if($secondary/xproc:input[@port=$name]//t:document) then&#xD;
    for $child in $secondary/xproc:input[@port=$name]/t:document/node()&#xD;
    return&#xD;
        document{$child}&#xD;
else&#xD;
    for $child in $secondary/xproc:input[@port=$name]/node()&#xD;
    return&#xD;
        document{$child}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-primary($primary){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if($primary//t:document) then&#xD;
	for $child in $primary/t:document/node()&#xD;
	return&#xD;
		    document{$child}&#xD;
else&#xD;
	for $child in $primary/*&#xD;
	return&#xD;
		    document{$child}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:random() as  xs:double  {&#xD;
   util:random()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:eval($exp as xs:string) as item()*{&#xD;
    util:eval($exp)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: TODO: refactor the following into a single function :)&#xD;
&#xD;
declare function u:call($func,$a) as item()*{&#xD;
    util:call($func,$a)&#xD;
};&#xD;
declare function u:call($func,$a,$b) as item()*{&#xD;
    util:call($func,$a,$b)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c) as item()*{&#xD;
    util:call($func,$a,$b,$c)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d,$e) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d,$e)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d,$e,$f) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d,$e,$f)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(:&#xD;
declare function u:function($func,$arity){&#xD;
    util:function($func, $arity)&#xD;
};&#xD;
:)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query,$xml){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
let $result := util:eval-with-context($qry,$static-content,false())&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query,$xml,$variables){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
                           {for $var in $variables&#xD;
                           return&#xD;
                           &lt;variable name="{$var/@name}"&gt;{$var/node()}&lt;/variable&gt;&#xD;
                           }&#xD;
&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
let $result := util:eval-with-context(fn:concat($const:default-ns-imports,$qry),$static-content,false())&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xsltmatchpattern($match,$xml,$variables){&#xD;
for $item in fn:tokenize($match,'\|')&#xD;
let $declarevars := for $var in $variables&#xD;
                           return&#xD;
                           concat('declare variable ',$var/@name,"",$var/node(),";")&#xD;
let $query := if (starts-with($item, '//')) then&#xD;
    concat($const:default-ns-imports,$declarevars,'.',$item)&#xD;
else if (starts-with($item,'/')) then&#xD;
    concat($const:default-ns-imports,$declarevars,'./',$item)&#xD;
else&#xD;
    concat($const:default-ns-imports,$declarevars,'.//',$item)&#xD;
let $declarens := u:declare-ns($xml)&#xD;
return&#xD;
    util:eval-inline($xml,$query)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery-with-context($query,$xml){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
&#xD;
let $result : = util:eval-inline($xml,$query)&#xD;
&#xD;
(:  let $result := util:eval-with-context($qry,$static-content,false())&#xD;
:)&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery-with-context($query,$xml,$variables){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
                            {for $var in $variables&#xD;
                           return&#xD;
                           &lt;variable name="{$var/@name}"&gt;{$var/node()}&lt;/variable&gt;&#xD;
                           }&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
	let $log-x := util:log("info",$variables)&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
&#xD;
let $result : = util:eval-inline($xml,$query)&#xD;
&#xD;
(:  let $result := util:eval-with-context($qry,$static-content,false())&#xD;
:)&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query as xs:string){&#xD;
    let $qry := if (starts-with($query,'/') or starts-with($query,'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else if($query eq '') then&#xD;
			    u:dynamicError('err:XD0001','query is empty and/or XProc step is not supported')&#xD;
              else&#xD;
                  $query&#xD;
    let $result := util:eval($qry)   &#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xslt($input,$style){&#xD;
    transform:transform($input, document{$style}, ())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:safe-evalXPATH($qry as xs:string, $xml,$pipeline){&#xD;
    util:catch("*",u:evalXPATH($qry, $xml, $pipeline/*),())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:safe-evalXPATH($qry as xs:string, $xml){&#xD;
    util:catch("*", u:evalXPATH($qry,$xml),())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($qry as xs:string, $xml){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
	    util:eval-inline($xml,$query)&#xD;
		(:&#xD;
		if ( $result instance of element() or $result instance of document-node()) then &#xD;
		&#xD;
			u:dynamicError('err:XD0016',$xpathstring)&#xD;
			:)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($qry as xs:string, $xml, $namespaces){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
        let $declarens := u:declare-ns($namespaces)&#xD;
        return&#xD;
	       util:eval-inline($xml,$query)&#xD;
&#xD;
		(:&#xD;
		if ( $result instance of element() or $result instance of document-node()) then&#xD;
			u:dynamicError('err:XD0016',$xpathstring)&#xD;
	    :)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xpathexpression($qry as xs:string, $xml, $namespaces){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
        let $declarens := u:declare-ns($namespaces)&#xD;
        return&#xD;
	       util:eval-inline($xml,$query)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:add-ns-node(&#xD;
    $elem   as element(),&#xD;
    $prefix as xs:string,&#xD;
    $ns-uri as xs:string&#xD;
  ) as element()&#xD;
{&#xD;
  element { QName($ns-uri, concat($prefix, ":x")) }{ $elem }/*&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:deep-equal-seq($primary,$secondary,$strict) {&#xD;
&#xD;
if ($strict eq '1') then&#xD;
let $e1 := (for $child in $primary/*&#xD;
		 return&#xD;
			$child)&#xD;
			&#xD;
let $e2 := (for $child in $secondary/*&#xD;
			return&#xD;
				$child)&#xD;
				&#xD;
return&#xD;
&#xD;
every $i in 1 to max((count($e1),count($e2)))&#xD;
satisfies deep-equal($e1[$i],$e2[$i])&#xD;
&#xD;
&#xD;
else&#xD;
&#xD;
let $e1 := (for $child in $primary/*&#xD;
		 return&#xD;
			u:treewalker($child))&#xD;
			&#xD;
let $e2 := (for $child in $secondary/*&#xD;
			return&#xD;
				u:treewalker($child))&#xD;
				&#xD;
return&#xD;
&#xD;
every $i in 1 to max((count($e1),count($e2)))&#xD;
satisfies deep-equal($e1[$i],$e2[$i])&#xD;
&#xD;
&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:treewalker($element) {&#xD;
element {node-name($element)}&#xD;
   {$element/@*,&#xD;
&#xD;
       for $child in $element/node()&#xD;
           return&#xD;
            if ($child instance of element()) then &#xD;
					u:treewalker($child)&#xD;
              else &#xD;
					normalize-space($child)&#xD;
															&#xD;
   }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:treewalker-add-attribute($element as element(),$match,$attrName,$attrValue) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
       if(name($element) = string($match)) then attribute {$attrName}{$attrValue} else (),&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
               if ($child instance of element())&#xD;
                 then u:treewalker-add-attribute($child,$match,$attrName,$attrValue)&#xD;
                 else $child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:copy-filter-elements($element as element(), $element-name as xs:string*) as element() {&#xD;
   element {node-name($element) }&#xD;
             { $element/@*,&#xD;
               for $child in $element/node()[not(name(.)=$element-name)]&#xD;
                  return if ($child instance of element())&#xD;
                    then u:copy-filter-elements($child,$element-name)&#xD;
                    else $child&#xD;
           }&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:rename-inline-element($element as element(),$match,$newelement) as element() {&#xD;
   element {if(string(node-name($element)) = string($match)) then node-name($newelement) else node-name($element)}&#xD;
      {$element/@*,&#xD;
       if(string(node-name($element)) = $match) then &#xD;
				($newelement/@*)&#xD;
		else &#xD;
			(),&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
               if ($child instance of element())&#xD;
                 then u:rename-inline-element($child,$match,$newelement)&#xD;
                 else $child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:delete-matching-elements($element as element(),$select) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*[not(. intersect $select)],&#xD;
          for $child in $element/node()[not(. intersect $select)]&#xD;
              return                             &#xD;
               if ($child instance of element())&#xD;
                 then &#xD;
                     u:delete-matching-elements($child,$select)&#xD;
                 else&#xD;
                     $child&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:replace-matching-elements($element as element(),$select,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
	    	    		$replace&#xD;
	    	    	else if ($child/text() eq $select ) then&#xD;
	    	    	    element {node-name($child)}{&#xD;
                            $replace&#xD;
 	    	    	    }&#xD;
	    	    	else if ($child/@* intersect $select) then&#xD;
	    	    	    &lt;test/&gt;&#xD;
&#xD;
    			    else&#xD;
                        u:replace-matching-elements($child,$select,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:insert-matching-elements($element as element(),$select,$replace,$position) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
						if($position eq 'before' or $position eq 'first-child') then&#xD;
							($replace,u:insert-matching-elements($child,$select,$replace,$position))&#xD;
						else if($position eq 'after' or $position eq 'last-child') then&#xD;
							(u:insert-matching-elements($child,$select,$replace,$position),$replace)&#xD;
						else	&#xD;
							u:insert-matching-elements($child,$select,$replace,$position)&#xD;
    			    else&#xD;
                        u:insert-matching-elements($child,$select,$replace,$position)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:rename-matching-elements($element as element(),$select,$new-name) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {$new-name}{$child/*&#xD;
						}						&#xD;
    			    else&#xD;
                        u:rename-matching-elements($child,$select,$new-name)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:wrap-matching-elements($element as element(),$select,$wrapper) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {$wrapper}{&#xD;
                        	u:wrap-matching-elements($child,$select,$wrapper)&#xD;
						}						&#xD;
    			    else&#xD;
                        u:wrap-matching-elements($child,$select,$wrapper)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:unwrap-matching-elements($element as element(),$select) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
                        	$child/*&#xD;
    			    else&#xD;
                        u:unwrap-matching-elements($child,$select)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:label-matching-elements($element as element(),$select,$attribute,$label,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{    &#xD;
				        attribute {$attribute} {$label,"_",$pos},&#xD;
                   		u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:label-matching-elements($element as element(),$select,$attribute,$label,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{    &#xD;
				        attribute {$attribute} {$label,"_",$pos},&#xD;
                   		u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:add-attribute-matching-elements($element as element(),$select,$attribute,$label) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {node-name($child)}{&#xD;
				    		$child/@*[not(name(.)=$attribute)],&#xD;
				        	attribute {$attribute} {$label},&#xD;
							if ($child/node() instance of text()) then&#xD;
								$child/text()&#xD;
							else if ($child/node() instance of element()) then						&#xD;
               					u:add-attribute-matching-elements($child,$select,$attribute,$label)&#xD;
							else&#xD;
								$child/*&#xD;
						}	&#xD;
    			    else&#xD;
                        u:add-attribute-matching-elements($child,$select,$attribute,$label)&#xD;
                &#xD;
				else if ($child/node() instance of text()) then&#xD;
                    $child/text()&#xD;
          		else &#xD;
					$child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:add-attributes-matching-elements($element as element(),$select,$attributes) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{&#xD;
				    	$attributes,&#xD;
                   		u:add-attributes-matching-elements($child,$select,$attributes)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:add-attributes-matching-elements($child,$select,$attributes)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:string-replace-matching-elements($element as element(),$select,$replace) as element() {&#xD;
&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element()) then&#xD;
        			if ($child intersect $select) then&#xD;
    	    			(util:log('info','attribute logged'),string($replace))&#xD;
			    	else&#xD;
                    	u:string-replace-matching-elements($child,$select,$replace)&#xD;
                else if ($child instance of attribute()) then&#xD;
        			if ($child intersect $select) then&#xD;
                        (util:log('INFO','***************** attribute logged'),attribute { name($child) } { string($replace) })&#xD;
			    	else&#xD;
                    	u:string-replace-matching-elements($child,$select,$replace)&#xD;
                else&#xD;
                    $child&#xD;
      }&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:treewalker ($tree,$attrFunc,$elemFunc) {&#xD;
&#xD;
  let $children := $tree/*&#xD;
  return&#xD;
      if(empty($children)) then ()&#xD;
      else&#xD;
        for $c in $children&#xD;
            return&#xD;
                ( element {node-name($c)}{&#xD;
                            u:call($attrFunc,$c/@*),&#xD;
                            u:call($elemFunc,$c/*),&#xD;
                        u:treewalker($tree,$attrFunc,$elemFunc)&#xD;
                })&#xD;
};&#xD;
&#xD;
declare function u:treewalker ($tree,$attrFunc,$textFunc,$attName,$attValue) {&#xD;
&#xD;
  let $children := $tree/*&#xD;
  return&#xD;
      if(empty($children)) then ()&#xD;
      else&#xD;
        for $c in $children&#xD;
            return&#xD;
                ( element {node-name($c)}{&#xD;
                            u:call($attrFunc,$c/@*,$attName,$attValue),&#xD;
                            u:call($textFunc,$c/text()),&#xD;
                        u:treewalker($c,$attrFunc,$textFunc,$attName,$attValue)&#xD;
                })&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:attrHandler ($attr,$attName,$attValue) {&#xD;
	$attr, attribute {string($attName)}{string($attValue)}&#xD;
 };&#xD;
&#xD;
declare function u:textHandler ($text) {&#xD;
	$text&#xD;
 };&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:declare-used-namespaces ( $root as node()? )  as xs:anyURI* {&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
return &#xD;
    let $ns := concat('ns',$pos)&#xD;
    return&#xD;
        util:declare-namespace($ns,$namespace)&#xD;
} ;&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:list-used-namespaces1 ( $root as node()? )  {&#xD;
let $prefix :=   (distinct-values($root/descendant-or-self::*/(.|@*)/substring-before(name(.), ':')) )&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
	return &#xD;
	 if ($namespace eq 'http://www.w3.org/XML/1998/namespace') then&#xD;
		()&#xD;
	 else if ($namespace eq 'http://www.w3.org/ns/xproc-step') then&#xD;
		()&#xD;
&#xD;
	 else&#xD;
		let $ns := $prefix[$pos]&#xD;
    			return&#xD;
         			concat('declare namespace ',$ns,'="',$namespace,'";')&#xD;
} ;&#xD;
&#xD;
 declare function u:list-used-namespaces ( $root as node()? )  as xs:string* {&#xD;
let $prefix :=   (distinct-values($root/descendant-or-self::*/(.|@*)/substring-before(name(.), ':')) )&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
    return &#xD;
        &#xD;
		let $ns := $prefix[$pos - 1]&#xD;
    			return&#xD;
            if ($namespace eq '') then&#xD;
                ()&#xD;
			else if ($namespace eq 'http://www.w3.org/XML/1998/namespace') then&#xD;
				()&#xD;
            else if ($ns) then 	&#xD;
       			concat('declare namespace ',$ns,'="',$namespace,'";')&#xD;
            else&#xD;
                concat('declare default element namespace "',$namespace,'";')&#xD;
} ;&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:validate($exp) as xs:string {&#xD;
$exp&#xD;
(:&#xD;
    nvdl:main("file:test/data/w3schema.xml file:test/data/schema-example.xml")&#xD;
:)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:serialize($xml,$options){&#xD;
	util:serialize($xml,$options)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:parse-string($string) as item()*{&#xD;
    util:parse($string)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:map($func, $seqA as item()*, $seqB as item()*) &#xD;
as item()* {&#xD;
	if(count($seqA) != count($seqB)) then ()&#xD;
	else&#xD;
    	for $a at $i in $seqA&#xD;
    	let $b := $seqB[$i]&#xD;
    	return&#xD;
        	u:call($func, $a, $b)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:filter($func, $seq as item()*) &#xD;
as item()* {&#xD;
	for $i in $seq&#xD;
	return&#xD;
		if(u:call($func, $i)) then&#xD;
			$i&#xD;
		else&#xD;
			()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: test folding the step with a different function :)&#xD;
declare function u:printstep ($step,$meta,$value) {&#xD;
    u:call( $step, $value)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:strip-namespace($e as element()) as element() {&#xD;
  &#xD;
   element {QName((),local-name($e))} {&#xD;
    for $child in $e/(@*,node())&#xD;
    return&#xD;
      if ($child instance of element())&#xD;
      then&#xD;
        u:strip-namespace($child)&#xD;
      else&#xD;
        $child&#xD;
  }&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:uniqueid($unique_id,$count){&#xD;
    concat($unique_id,'.',$count)&#xD;
};&#xD;
&#xD;
:)&#xD;
&#xD;
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><div><textarea rows="20" cols="100"><doc:xqdoc xmlns:doc="http://www.xqdoc.org/1.0"><doc:control><XQuery><Module><VersionDecl>(: ------------------------------------------------------------------------------------- &#xD;
 &#xD;
	util.xqm - contains most of the XQuery processor specific functions, including all&#xD;
	helper functions.&#xD;
	&#xD;
---------------------------------------------------------------------------------------- :)&#xD;
<TOKEN>xquery</TOKEN><TOKEN>version</TOKEN><StringLiteral>"3.0"</StringLiteral><TOKEN>encoding</TOKEN><StringLiteral>"UTF-8"</StringLiteral><Separator><TOKEN>;</TOKEN></Separator></VersionDecl><LibraryModule><ModuleDecl><TOKEN>module</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>u</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc/util"</URILiteral><Separator><TOKEN>;</TOKEN></Separator></ModuleDecl><Prolog><NamespaceDecl>&#xD;
&#xD;
(: declare namespaces :)&#xD;
<TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>p</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://www.w3.org/ns/xproc"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>c</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://www.w3.org/ns/xproc-step"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>err</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://www.w3.org/ns/xproc-error"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>xsl</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://www.w3.org/1999/XSL/Transform"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>xproc</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>std</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc/std"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>opt</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc/opt"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>ext</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc/ext"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><NamespaceDecl><TOKEN>declare</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>xxq-error</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc/error"</URILiteral></NamespaceDecl><Separator><TOKEN>;</TOKEN></Separator><Import><ModuleImport>&#xD;
&#xD;
&#xD;
(: Module Imports :)&#xD;
<TOKEN>import</TOKEN><TOKEN>module</TOKEN><TOKEN>namespace</TOKEN><NCName><NCName>const</NCName></NCName><TOKEN>=</TOKEN><URILiteral>"http://xproc.net/xproc/const"</URILiteral><TOKEN>at</TOKEN><URILiteral>"const.xqm"</URILiteral></ModuleImport></Import><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: set to 1 to enable debugging :)&#xD;
<TOKEN>declare</TOKEN><VarDecl><TOKEN>variable</TOKEN><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>u:NDEBUG</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><VarValue><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>const:NDEBUG</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></VarValue></VarDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:store</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>href</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>data</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>result</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:result-document</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>href</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>data</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:output</QName><DirAttributeList><S/><QName>method</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>x</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>m</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>l</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>href</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:parse</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>data</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType></SequenceType><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<EQName>saxon:parse</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>data</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:serialize</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<EQName>saxon:serialize</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:output</QName><DirAttributeList><S/><QName>method</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>x</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>m</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>l</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>omit-xml-declaration</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>y</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>e</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>s</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>indent</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>y</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>e</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>s</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>saxon:indent-spaces</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>1</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:dirlist</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>path</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<EQName>collection</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>concat</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>path</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>"?select=*.*;recurse=yes;on-error=ignore"</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:evalXPATH</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>xpath</EQName></FunctionName></EQName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><IfExpr>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
  <TOKEN>if</TOKEN><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xpath</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr><ValueComp><TOKEN>eq</TOKEN></ValueComp><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'/'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr><TOKEN>or</TOKEN><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xpath</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr><ValueComp><TOKEN>eq</TOKEN></ValueComp><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>''</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr><TOKEN>or</TOKEN><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><TOKEN>empty</TOKEN></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN><TOKEN>then</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle><TOKEN>else</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><PostfixExpr><PrimaryExpr><ContextItemExpr><TOKEN>.</TOKEN></ContextItemExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:evaluate</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xpath</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></IfExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:transform</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>stylesheet</EQName></FunctionName></EQName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
  <TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>rendition</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:compile-stylesheet</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><ComputedConstructor><CompDocConstructor><TOKEN>document</TOKEN><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>stylesheet</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></CompDocConstructor></ComputedConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:transform</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>rendition</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:xsltMatchPattern</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>xpath</EQName></FunctionName></EQName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><TOKEN>node</TOKEN></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>match</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><ComputedConstructor><CompDocConstructor><TOKEN>document</TOKEN><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:stylesheet</QName><DirAttributeList><S/><QName>version</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>2</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>.</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>0</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>&gt;</TOKEN><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:template</QName><DirAttributeList><S/><QName>match</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><CommonContent><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xpath</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></CommonContent></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>&gt;</TOKEN><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:apply-templates</QName><DirAttributeList><S/><QName>mode</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>m</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><TOKEN>&lt;/</TOKEN><QName>xsl:template</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></DirectConstructor></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:template</QName><DirAttributeList><S/><QName>match</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>@</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>*</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>|</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>n</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>o</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>d</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>e</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>(</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>)</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>mode</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>m</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>&gt;</TOKEN><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:copy</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:apply-templates</QName><DirAttributeList><S/><QName>select</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>@</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>*</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>|</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>n</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>o</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>d</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>e</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>(</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>)</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>mode</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>m</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><TOKEN>&lt;/</TOKEN><QName>xsl:copy</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></DirectConstructor></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><TOKEN>&lt;/</TOKEN><QName>xsl:template</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></DirectConstructor></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:template</QName><DirAttributeList><S/><QName>match</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>t</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>e</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>x</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>t</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>(</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>)</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><DirElemContent><ElementContentChar/></DirElemContent><TOKEN>&lt;/</TOKEN><QName>xsl:stylesheet</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></CompDocConstructor></ComputedConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><IntermediateClause><InitialClause><LetClause><TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>rendition</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:compile-stylesheet</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>match</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause></IntermediateClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:transform</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>rendition</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><TOKEN>node</TOKEN></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:outputResultElement</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>exp</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    <TOKEN>&lt;</TOKEN><QName>c:result</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><DirElemContent><CommonContent><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>exp</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></CommonContent></DirElemContent><TOKEN>&lt;/</TOKEN><QName>c:result</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:get-secondary</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>name</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>secondary</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><KindTest><ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><ElementNameOrWildcard><ElementName><EQName><FunctionName><EQName>xproc:input</EQName></FunctionName></EQName></ElementName></ElementNameOrWildcard><TOKEN>)</TOKEN></ElementTest></KindTest></ItemType><OccurrenceIndicator><TOKEN>*</TOKEN></OccurrenceIndicator></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><OccurrenceIndicator><TOKEN>*</TOKEN></OccurrenceIndicator></SequenceType><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    <TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>secondary</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr><Predicate><TOKEN>[</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><TOKEN>@</TOKEN><NodeTest><NameTest><EQName><FunctionName><EQName>port</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr><ValueComp><TOKEN>eq</TOKEN></ValueComp><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>name</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>]</TOKEN></Predicate></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><KindTest><AnyKindTest><TOKEN>node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></AnyKindTest></KindTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:get-option</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>option-name</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>options</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><KindTest><ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><ElementNameOrWildcard><ElementName><EQName><FunctionName><EQName>xproc:options</EQName></FunctionName></EQName></ElementName></ElementNameOrWildcard><TOKEN>)</TOKEN></ElementTest></KindTest></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>primary</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType><OccurrenceIndicator><TOKEN>*</TOKEN></OccurrenceIndicator></SequenceType><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>value</EQName></FunctionName></EQName></VarName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>replace</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>string</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>options</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>//</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><NameTest><EQName><FunctionName><EQName>p:with-option</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList><Predicate><TOKEN>[</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><TOKEN>@</TOKEN><NodeTest><NameTest><EQName><FunctionName><EQName>name</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr><ValueComp><TOKEN>eq</TOKEN></ValueComp><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>option-name</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>]</TOKEN></Predicate></PredicateList></AxisStep></StepExpr><TOKEN>/</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><TOKEN>@</TOKEN><NodeTest><NameTest><EQName><FunctionName><EQName>select</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'&amp;quot;'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>''</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>value</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: PRIMARY UTILITIES                                                          :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:result-document</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>href</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>doc</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>writelog</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>saxon:result-document</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>href</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>doc</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>xsl:output</QName><DirAttributeList><S/><QName>method</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>x</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>m</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>l</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>indent</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><QuotAttrContentChar>y</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>e</QuotAttrContentChar></QuotAttrValueContent><QuotAttrValueContent><QuotAttrContentChar>s</QuotAttrContentChar></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>href</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:dynamicError</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>string</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    <TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>info</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>const:error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>//</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><NameTest><EQName><FunctionName><EQName>err:error</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList><Predicate><TOKEN>[</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><TOKEN>@</TOKEN><NodeTest><NameTest><EQName><FunctionName><EQName>code</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr><GeneralComp><TOKEN>=</TOKEN></GeneralComp><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>substring-after</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>':'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>]</TOKEN></Predicate></PredicateList></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>error</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>QName</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'http://www.w3.org/ns/xproc-error'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>concat</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>": XProc Dynamic Error - "</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>string</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>" "</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>info</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><KindTest><TextTest><TOKEN>text</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></TextTest></KindTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'&amp;#10;'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:stepError</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>string</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><LetClause>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>let</TOKEN><LetBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>info</EQName></FunctionName></EQName></VarName><TOKEN>:=</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>const:error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>//</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><NameTest><EQName><FunctionName><EQName>err:error</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList><Predicate><TOKEN>[</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><TOKEN>@</TOKEN><NodeTest><NameTest><EQName><FunctionName><EQName>code</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr><GeneralComp><TOKEN>=</TOKEN></GeneralComp><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>substring-after</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>':'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>]</TOKEN></Predicate></PredicateList></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></LetBinding></LetClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>error</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>QName</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'http://www.w3.org/ns/xproc-error'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>concat</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>": XProc Step Error - "</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>string</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>" "</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>info</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><KindTest><TextTest><TOKEN>text</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></TextTest></KindTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'&amp;#10;'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl><TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:binary-doc</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>uri</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl><TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:binary-to-string</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>data</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:serialize</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>options</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>xml</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: ASSERTIONS, DEBUG TOOLS                                                    :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:trace</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>value</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><OccurrenceIndicator><TOKEN>*</TOKEN></OccurrenceIndicator></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>what</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>boolean</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>const:NDEBUG</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN><TOKEN>then</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>trace</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>value</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>what</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle><TOKEN>else</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></IfExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:asserterror</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>errortype</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>booleanexp</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>why</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>not</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>booleanexp</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr><TOKEN>and</TOKEN><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>boolean</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>const:NDEBUG</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN><TOKEN>then</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>u:dynamicError</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>fn:QName</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'http://www.w3.org/ns/xproc-error'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>errortype</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>why</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle><TOKEN>else</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></IfExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:assert</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>booleanexp</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>why</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>not</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>booleanexp</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr><TOKEN>and</TOKEN><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>boolean</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>const:NDEBUG</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN><TOKEN>then</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>u:dynamicError</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'err:XC0020'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>why</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle><TOKEN>else</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></IfExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:assert</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>booleanexp</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>why</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><AtomicOrUnionType><EQName><FunctionName><EQName>xs:string</EQName></FunctionName></EQName></AtomicOrUnionType></ItemType></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><IfExpr>&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
<TOKEN>if</TOKEN><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>not</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>booleanexp</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr><TOKEN>and</TOKEN><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>boolean</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>u:NDEBUG</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN><TOKEN>then</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>error</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>QName</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>'http://www.w3.org/ns/xproc-error'</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>error</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>concat</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Literal><StringLiteral>"XProc Assert Error: "</StringLiteral></Literal></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>why</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle><TOKEN>else</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></IfExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl>&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: manage namespaces                                                          :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
<TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:declarens</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><TOKEN>element</TOKEN></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>u:declare-ns</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>u:enum-ns</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><TOKEN>element</TOKEN></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl><TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:declare-ns</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>namespaces</EQName></FunctionName></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><ForClause><TOKEN>for</TOKEN><ForBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>ns</EQName></FunctionName></EQName></VarName><TOKEN>in</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>namespaces</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>//</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><NameTest><EQName><FunctionName><EQName>ns</EQName></FunctionName></EQName></NameTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ForBinding></ForClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl><TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:namespaces-in-use</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><FunctionName><EQName>root</EQName></FunctionName></EQName><TypeDeclaration><TOKEN>as</TOKEN><SequenceType><ItemType><KindTest><AnyKindTest><TOKEN>node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></AnyKindTest></KindTest></ItemType><OccurrenceIndicator><TOKEN>?</TOKEN></OccurrenceIndicator></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><ForClause><TOKEN>for</TOKEN><ForBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>ns</EQName></FunctionName></EQName></VarName><TOKEN>in</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>distinct-values</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>root</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><AxisStep><ForwardStep><ForwardAxis><TOKEN>descendant-or-self</TOKEN><TOKEN>::</TOKEN></ForwardAxis><NodeTest><NameTest><Wildcard>*</Wildcard></NameTest></NodeTest></ForwardStep><PredicateList/></AxisStep></StepExpr><TOKEN>/</TOKEN><StepExpr><PostfixExpr><PrimaryExpr><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ContextItemExpr><TOKEN>.</TOKEN></ContextItemExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN></ParenthesizedExpr></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>in-scope-prefixes</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><ContextItemExpr><TOKEN>.</TOKEN></ContextItemExpr></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ForBinding></ForClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>ns</QName><DirAttributeList><S/><QName>prefix</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><CommonContent><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>ns</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></CommonContent></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue><S/><QName>URI</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrValueContent><CommonContent><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>namespace-uri-for-prefix</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>ns</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>,</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><EQName>root</EQName></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></CommonContent></QuotAttrValueContent><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator><AnnotatedDecl><TOKEN>declare</TOKEN><FunctionDecl><TOKEN>function</TOKEN><EQName><FunctionName><EQName>u:enum-ns</EQName></FunctionName></EQName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><EQName><TOKEN>element</TOKEN></EQName></Param></ParamList><TOKEN>)</TOKEN><FunctionBody><EnclosedExpr><TOKEN>{</TOKEN><Expr><ExprSingle><FLWORExpr><InitialClause><ForClause><TOKEN>for</TOKEN><ForBinding><TOKEN>$</TOKEN><VarName><EQName><FunctionName><TOKEN>child</TOKEN></FunctionName></EQName></VarName><TOKEN>in</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><TOKEN>element</TOKEN></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr><TOKEN>/</TOKEN><StepExpr><AxisStep><ForwardStep><AbbrevForwardStep><NodeTest><KindTest><AnyKindTest><TOKEN>node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></AnyKindTest></KindTest></NodeTest></AbbrevForwardStep></ForwardStep><PredicateList/></AxisStep></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></ForBinding></ForClause></InitialClause><ReturnClause><TOKEN>return</TOKEN><ExprSingle><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><Expr><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><TOKEN>child</TOKEN></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr><TOKEN>instance</TOKEN><TOKEN>of</TOKEN><SequenceType><ItemType><KindTest><ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ElementTest></KindTest></ItemType></SequenceType></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr><TOKEN>or</TOKEN><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><TOKEN>child</TOKEN></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr><TOKEN>instance</TOKEN><TOKEN>of</TOKEN><SequenceType><ItemType><KindTest><DocumentTest><TOKEN>document-node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></DocumentTest></KindTest></ItemType></SequenceType></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Expr><TOKEN>)</TOKEN><TOKEN>then</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><FunctionCall><FunctionName><EQName>u:namespaces-in-use</EQName></FunctionName><ArgumentList><TOKEN>(</TOKEN><Argument><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><VarRef><TOKEN>$</TOKEN><VarName><EQName><FunctionName><TOKEN>child</TOKEN></FunctionName></EQName></VarName></VarRef></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></Argument><TOKEN>)</TOKEN></ArgumentList></FunctionCall></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle><TOKEN>else</TOKEN><ExprSingle><OrExpr><AndExpr><ComparisonExpr><RangeExpr><AdditiveExpr><MultiplicativeExpr><UnionExpr><IntersectExceptExpr><InstanceofExpr><TreatExpr><CastableExpr><CastExpr><UnaryExpr><ValueExpr><PathExpr><RelativePathExpr><StepExpr><PostfixExpr><PrimaryExpr><Constructor><DirectConstructor><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>ns</QName><DirAttributeList/><TOKEN>/&gt;</TOKEN></DirElemConstructor></DirectConstructor></Constructor></PrimaryExpr></PostfixExpr></StepExpr></RelativePathExpr></PathExpr></ValueExpr></UnaryExpr></CastExpr></CastableExpr></TreatExpr></InstanceofExpr></IntersectExceptExpr></UnionExpr></MultiplicativeExpr></AdditiveExpr></RangeExpr></ComparisonExpr></AndExpr></OrExpr></ExprSingle></IfExpr></ExprSingle></ReturnClause></FLWORExpr></ExprSingle></Expr><TOKEN>}</TOKEN></EnclosedExpr></FunctionBody></FunctionDecl></AnnotatedDecl><Separator><TOKEN>;</TOKEN></Separator></Prolog></LibraryModule></Module>&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: DEPRECATED &#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: generate unique id														  :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:uniqueid($unique_id,$count) as xs:string{&#xD;
    concat($unique_id,'.',$count)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns comp from comp definitions :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-comp($compname as xs:string) {&#xD;
    $const:comp-steps//xproc:element[@type=$compname]&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: checks to see if this component exists :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:comp-available($compname as xs:string) as xs:boolean {&#xD;
        exists(u:get-comp($compname))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns step from std, opt and ext step definitions :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-step($stepname as xs:string,$declarestep) {&#xD;
    $const:std-steps/p:declare-step[@type=$stepname],&#xD;
    $const:opt-steps/p:declare-step[@type=$stepname],&#xD;
    $const:ext-steps/p:declare-step[@type=$stepname],&#xD;
    $const:comp-steps//xproc:element[@type=$stepname], &#xD;
    $declarestep/@type&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: returns step type :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:type($stepname as xs:string,$is_declare-step) as xs:string {&#xD;
&#xD;
    let $stdstep := $const:std-steps/p:declare-step[@type=$stepname]&#xD;
    let $optstep := $const:opt-steps/p:declare-step[@type=$stepname]&#xD;
    let $extstep := $const:ext-steps/p:declare-step[@type=$stepname]&#xD;
    let $component :=$const:comp-steps//xproc:element[@type=$stepname]&#xD;
&#xD;
    let $stdstepexists := exists($stdstep)&#xD;
    let $optstepexists := exists($optstep)&#xD;
    let $extstepexists := exists($extstep)&#xD;
    let $compexists := exists($component)&#xD;
    return&#xD;
        if ($optstepexists) then&#xD;
            'opt'&#xD;
        else if($extstepexists) then&#xD;
            'ext'&#xD;
        else if($stdstepexists) then&#xD;
            'std'&#xD;
        else if($compexists) then&#xD;
            'comp'&#xD;
        else if($is_declare-step) then&#xD;
          string(substring-before($is_declare-step/@type,':'))&#xD;
        else&#xD;
          u:staticError('err:XS0044', concat($stepname,":",$stepname,' has no visible declaration'))&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:boolean($test as xs:string)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if(contains($test,'false') ) then &#xD;
    false()&#xD;
else&#xD;
    true()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:uuid()  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
	util:uuid()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:hash($data,$algorithm)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
	if (contains($algorithm, "md"))then&#xD;
	  util:hash($data, 'md5')&#xD;
	 else&#xD;
 	  util:hash($data,$algorithm)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:unparsed-data($uri as xs:string, $mediatype as xs:string)  {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
	util:binary-to-string(util:binary-doc($uri))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: TODO: consider combining error throwing functions :)&#xD;
(: consider adding saxon:line-number()  :)&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:dynamicError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
    let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Dynamic Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:staticError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Static Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:stepError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:error//err:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://www.w3.org/ns/xproc-error',$error),concat($error,": XProc Step Error - ",$string," ",$info/text(),'&amp;#10;'))&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xprocxqError($error,$string) {&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
let $info := $const:xprocxq-error//xxq-error:error[@code=substring-after($error,':')]&#xD;
    return&#xD;
        error(QName('http://xproc.net/xproc/error',$error),concat($error,": xprocxq error - ",$string," ",$info/text(),'&amp;#10;'))};&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-secondary($name as xs:string,$secondary){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
if($secondary/xproc:input[@port=$name]//t:document) then&#xD;
    for $child in $secondary/xproc:input[@port=$name]/t:document/node()&#xD;
    return&#xD;
        document{$child}&#xD;
else&#xD;
    for $child in $secondary/xproc:input[@port=$name]/node()&#xD;
    return&#xD;
        document{$child}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:get-primary($primary){&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
if($primary//t:document) then&#xD;
	for $child in $primary/t:document/node()&#xD;
	return&#xD;
		    document{$child}&#xD;
else&#xD;
	for $child in $primary/*&#xD;
	return&#xD;
		    document{$child}&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:random() as  xs:double  {&#xD;
   util:random()&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:eval($exp as xs:string) as item()*{&#xD;
    util:eval($exp)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: TODO: refactor the following into a single function :)&#xD;
&#xD;
declare function u:call($func,$a) as item()*{&#xD;
    util:call($func,$a)&#xD;
};&#xD;
declare function u:call($func,$a,$b) as item()*{&#xD;
    util:call($func,$a,$b)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c) as item()*{&#xD;
    util:call($func,$a,$b,$c)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d,$e) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d,$e)&#xD;
};&#xD;
declare function u:call($func,$a,$b,$c,$d,$e,$f) as item()*{&#xD;
    util:call($func,$a,$b,$c,$d,$e,$f)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(:&#xD;
declare function u:function($func,$arity){&#xD;
    util:function($func, $arity)&#xD;
};&#xD;
:)&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query,$xml){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
let $result := util:eval-with-context($qry,$static-content,false())&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query,$xml,$variables){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
                           {for $var in $variables&#xD;
                           return&#xD;
                           &lt;variable name="{$var/@name}"&gt;{$var/node()}&lt;/variable&gt;&#xD;
                           }&#xD;
&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
let $result := util:eval-with-context(fn:concat($const:default-ns-imports,$qry),$static-content,false())&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xsltmatchpattern($match,$xml,$variables){&#xD;
for $item in fn:tokenize($match,'\|')&#xD;
let $declarevars := for $var in $variables&#xD;
                           return&#xD;
                           concat('declare variable ',$var/@name,"",$var/node(),";")&#xD;
let $query := if (starts-with($item, '//')) then&#xD;
    concat($const:default-ns-imports,$declarevars,'.',$item)&#xD;
else if (starts-with($item,'/')) then&#xD;
    concat($const:default-ns-imports,$declarevars,'./',$item)&#xD;
else&#xD;
    concat($const:default-ns-imports,$declarevars,'.//',$item)&#xD;
let $declarens := u:declare-ns($xml)&#xD;
return&#xD;
    util:eval-inline($xml,$query)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery-with-context($query,$xml){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
&#xD;
let $result : = util:eval-inline($xml,$query)&#xD;
&#xD;
(:  let $result := util:eval-with-context($qry,$static-content,false())&#xD;
:)&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery-with-context($query,$xml,$variables){&#xD;
    let $static-content := &lt;static-context&gt;&#xD;
                            {for $var in $variables&#xD;
                           return&#xD;
                           &lt;variable name="{$var/@name}"&gt;{$var/node()}&lt;/variable&gt;&#xD;
                           }&#xD;
						&lt;default-context&gt;{$xml}&lt;/default-context&gt;&#xD;
						&lt;/static-context&gt;&#xD;
	let $log-x := util:log("info",$variables)&#xD;
    let $qry := if (starts-with(normalize-space($query),'/') or starts-with(normalize-space($query),'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else&#xD;
                  $query&#xD;
&#xD;
&#xD;
let $result : = util:eval-inline($xml,$query)&#xD;
&#xD;
(:  let $result := util:eval-with-context($qry,$static-content,false())&#xD;
:)&#xD;
    return&#xD;
        $result&#xD;
};&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xquery($query as xs:string){&#xD;
    let $qry := if (starts-with($query,'/') or starts-with($query,'//')) then&#xD;
                concat('.',$query)&#xD;
			  else if(contains($query,'(/')) then&#xD;
				replace($query,'\(/','(./')&#xD;
              else if($query eq '') then&#xD;
			    u:dynamicError('err:XD0001','query is empty and/or XProc step is not supported')&#xD;
              else&#xD;
                  $query&#xD;
    let $result := util:eval($qry)   &#xD;
    return&#xD;
        $result&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xslt($input,$style){&#xD;
    transform:transform($input, document{$style}, ())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:safe-evalXPATH($qry as xs:string, $xml,$pipeline){&#xD;
    util:catch("*",u:evalXPATH($qry, $xml, $pipeline/*),())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:safe-evalXPATH($qry as xs:string, $xml){&#xD;
    util:catch("*", u:evalXPATH($qry,$xml),())&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($qry as xs:string, $xml){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
	    util:eval-inline($xml,$query)&#xD;
		(:&#xD;
		if ( $result instance of element() or $result instance of document-node()) then &#xD;
		&#xD;
			u:dynamicError('err:XD0016',$xpathstring)&#xD;
			:)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:evalXPATH($qry as xs:string, $xml, $namespaces){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
        let $declarens := u:declare-ns($namespaces)&#xD;
        return&#xD;
	       util:eval-inline($xml,$query)&#xD;
&#xD;
		(:&#xD;
		if ( $result instance of element() or $result instance of document-node()) then&#xD;
			u:dynamicError('err:XD0016',$xpathstring)&#xD;
	    :)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:xpathexpression($qry as xs:string, $xml, $namespaces){&#xD;
&#xD;
if(empty($qry) or $qry eq '/') then&#xD;
	$xml&#xD;
else&#xD;
	let $query := if (starts-with($qry,'/') or starts-with($qry,'//')) then&#xD;
                concat('.',$qry)&#xD;
			  else if(contains($qry,'(/')) then&#xD;
				replace($qry,'\(/','(./')&#xD;
              else&#xD;
                  $qry&#xD;
    return&#xD;
        let $declarens := u:declare-ns($namespaces)&#xD;
        return&#xD;
	       util:eval-inline($xml,$query)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:add-ns-node(&#xD;
    $elem   as element(),&#xD;
    $prefix as xs:string,&#xD;
    $ns-uri as xs:string&#xD;
  ) as element()&#xD;
{&#xD;
  element { QName($ns-uri, concat($prefix, ":x")) }{ $elem }/*&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:deep-equal-seq($primary,$secondary,$strict) {&#xD;
&#xD;
if ($strict eq '1') then&#xD;
let $e1 := (for $child in $primary/*&#xD;
		 return&#xD;
			$child)&#xD;
			&#xD;
let $e2 := (for $child in $secondary/*&#xD;
			return&#xD;
				$child)&#xD;
				&#xD;
return&#xD;
&#xD;
every $i in 1 to max((count($e1),count($e2)))&#xD;
satisfies deep-equal($e1[$i],$e2[$i])&#xD;
&#xD;
&#xD;
else&#xD;
&#xD;
let $e1 := (for $child in $primary/*&#xD;
		 return&#xD;
			u:treewalker($child))&#xD;
			&#xD;
let $e2 := (for $child in $secondary/*&#xD;
			return&#xD;
				u:treewalker($child))&#xD;
				&#xD;
return&#xD;
&#xD;
every $i in 1 to max((count($e1),count($e2)))&#xD;
satisfies deep-equal($e1[$i],$e2[$i])&#xD;
&#xD;
&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:treewalker($element) {&#xD;
element {node-name($element)}&#xD;
   {$element/@*,&#xD;
&#xD;
       for $child in $element/node()&#xD;
           return&#xD;
            if ($child instance of element()) then &#xD;
					u:treewalker($child)&#xD;
              else &#xD;
					normalize-space($child)&#xD;
															&#xD;
   }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:treewalker-add-attribute($element as element(),$match,$attrName,$attrValue) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
       if(name($element) = string($match)) then attribute {$attrName}{$attrValue} else (),&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
               if ($child instance of element())&#xD;
                 then u:treewalker-add-attribute($child,$match,$attrName,$attrValue)&#xD;
                 else $child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:copy-filter-elements($element as element(), $element-name as xs:string*) as element() {&#xD;
   element {node-name($element) }&#xD;
             { $element/@*,&#xD;
               for $child in $element/node()[not(name(.)=$element-name)]&#xD;
                  return if ($child instance of element())&#xD;
                    then u:copy-filter-elements($child,$element-name)&#xD;
                    else $child&#xD;
           }&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:rename-inline-element($element as element(),$match,$newelement) as element() {&#xD;
   element {if(string(node-name($element)) = string($match)) then node-name($newelement) else node-name($element)}&#xD;
      {$element/@*,&#xD;
       if(string(node-name($element)) = $match) then &#xD;
				($newelement/@*)&#xD;
		else &#xD;
			(),&#xD;
          for $child in $element/node()&#xD;
              return&#xD;
               if ($child instance of element())&#xD;
                 then u:rename-inline-element($child,$match,$newelement)&#xD;
                 else $child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:delete-matching-elements($element as element(),$select) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*[not(. intersect $select)],&#xD;
          for $child in $element/node()[not(. intersect $select)]&#xD;
              return                             &#xD;
               if ($child instance of element())&#xD;
                 then &#xD;
                     u:delete-matching-elements($child,$select)&#xD;
                 else&#xD;
                     $child&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:replace-matching-elements($element as element(),$select,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
	    	    		$replace&#xD;
	    	    	else if ($child/text() eq $select ) then&#xD;
	    	    	    element {node-name($child)}{&#xD;
                            $replace&#xD;
 	    	    	    }&#xD;
	    	    	else if ($child/@* intersect $select) then&#xD;
	    	    	    &lt;test/&gt;&#xD;
&#xD;
    			    else&#xD;
                        u:replace-matching-elements($child,$select,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:insert-matching-elements($element as element(),$select,$replace,$position) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
						if($position eq 'before' or $position eq 'first-child') then&#xD;
							($replace,u:insert-matching-elements($child,$select,$replace,$position))&#xD;
						else if($position eq 'after' or $position eq 'last-child') then&#xD;
							(u:insert-matching-elements($child,$select,$replace,$position),$replace)&#xD;
						else	&#xD;
							u:insert-matching-elements($child,$select,$replace,$position)&#xD;
    			    else&#xD;
                        u:insert-matching-elements($child,$select,$replace,$position)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
declare function u:rename-matching-elements($element as element(),$select,$new-name) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {$new-name}{$child/*&#xD;
						}						&#xD;
    			    else&#xD;
                        u:rename-matching-elements($child,$select,$new-name)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:wrap-matching-elements($element as element(),$select,$wrapper) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {$wrapper}{&#xD;
                        	u:wrap-matching-elements($child,$select,$wrapper)&#xD;
						}						&#xD;
    			    else&#xD;
                        u:wrap-matching-elements($child,$select,$wrapper)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:unwrap-matching-elements($element as element(),$select) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
                        	$child/*&#xD;
    			    else&#xD;
                        u:unwrap-matching-elements($child,$select)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:label-matching-elements($element as element(),$select,$attribute,$label,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{    &#xD;
				        attribute {$attribute} {$label,"_",$pos},&#xD;
                   		u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:label-matching-elements($element as element(),$select,$attribute,$label,$replace) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{    &#xD;
				        attribute {$attribute} {$label,"_",$pos},&#xD;
                   		u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:label-matching-elements($child,$select,$attribute,$label,$replace)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:add-attribute-matching-elements($element as element(),$select,$attribute,$label) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
&#xD;
            		if ($child intersect $select) then&#xD;
				   		element {node-name($child)}{&#xD;
				    		$child/@*[not(name(.)=$attribute)],&#xD;
				        	attribute {$attribute} {$label},&#xD;
							if ($child/node() instance of text()) then&#xD;
								$child/text()&#xD;
							else if ($child/node() instance of element()) then						&#xD;
               					u:add-attribute-matching-elements($child,$select,$attribute,$label)&#xD;
							else&#xD;
								$child/*&#xD;
						}	&#xD;
    			    else&#xD;
                        u:add-attribute-matching-elements($child,$select,$attribute,$label)&#xD;
                &#xD;
				else if ($child/node() instance of text()) then&#xD;
                    $child/text()&#xD;
          		else &#xD;
					$child&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:add-attributes-matching-elements($element as element(),$select,$attributes) as element() {&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element())&#xD;
                then&#xD;
            		if ($child intersect $select) then&#xD;
				   element {node-name($child)}{&#xD;
				    	$attributes,&#xD;
                   		u:add-attributes-matching-elements($child,$select,$attributes)&#xD;
						}	&#xD;
    			    else&#xD;
                        u:add-attributes-matching-elements($child,$select,$attributes)&#xD;
                else&#xD;
                    $child          		&#xD;
      }&#xD;
};&#xD;
&#xD;
declare function u:string-replace-matching-elements($element as element(),$select,$replace) as element() {&#xD;
&#xD;
   element {node-name($element)}&#xD;
      {$element/@*,&#xD;
          for $child at $pos in $element/node()&#xD;
              return                   &#xD;
              if ($child instance of element()) then&#xD;
        			if ($child intersect $select) then&#xD;
    	    			(util:log('info','attribute logged'),string($replace))&#xD;
			    	else&#xD;
                    	u:string-replace-matching-elements($child,$select,$replace)&#xD;
                else if ($child instance of attribute()) then&#xD;
        			if ($child intersect $select) then&#xD;
                        (util:log('INFO','***************** attribute logged'),attribute { name($child) } { string($replace) })&#xD;
			    	else&#xD;
                    	u:string-replace-matching-elements($child,$select,$replace)&#xD;
                else&#xD;
                    $child&#xD;
      }&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:treewalker ($tree,$attrFunc,$elemFunc) {&#xD;
&#xD;
  let $children := $tree/*&#xD;
  return&#xD;
      if(empty($children)) then ()&#xD;
      else&#xD;
        for $c in $children&#xD;
            return&#xD;
                ( element {node-name($c)}{&#xD;
                            u:call($attrFunc,$c/@*),&#xD;
                            u:call($elemFunc,$c/*),&#xD;
                        u:treewalker($tree,$attrFunc,$elemFunc)&#xD;
                })&#xD;
};&#xD;
&#xD;
declare function u:treewalker ($tree,$attrFunc,$textFunc,$attName,$attValue) {&#xD;
&#xD;
  let $children := $tree/*&#xD;
  return&#xD;
      if(empty($children)) then ()&#xD;
      else&#xD;
        for $c in $children&#xD;
            return&#xD;
                ( element {node-name($c)}{&#xD;
                            u:call($attrFunc,$c/@*,$attName,$attValue),&#xD;
                            u:call($textFunc,$c/text()),&#xD;
                        u:treewalker($c,$attrFunc,$textFunc,$attName,$attValue)&#xD;
                })&#xD;
};&#xD;
&#xD;
&#xD;
declare function u:attrHandler ($attr,$attName,$attValue) {&#xD;
	$attr, attribute {string($attName)}{string($attValue)}&#xD;
 };&#xD;
&#xD;
declare function u:textHandler ($text) {&#xD;
	$text&#xD;
 };&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:declare-used-namespaces ( $root as node()? )  as xs:anyURI* {&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
return &#xD;
    let $ns := concat('ns',$pos)&#xD;
    return&#xD;
        util:declare-namespace($ns,$namespace)&#xD;
} ;&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:list-used-namespaces1 ( $root as node()? )  {&#xD;
let $prefix :=   (distinct-values($root/descendant-or-self::*/(.|@*)/substring-before(name(.), ':')) )&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
	return &#xD;
	 if ($namespace eq 'http://www.w3.org/XML/1998/namespace') then&#xD;
		()&#xD;
	 else if ($namespace eq 'http://www.w3.org/ns/xproc-step') then&#xD;
		()&#xD;
&#xD;
	 else&#xD;
		let $ns := $prefix[$pos]&#xD;
    			return&#xD;
         			concat('declare namespace ',$ns,'="',$namespace,'";')&#xD;
} ;&#xD;
&#xD;
 declare function u:list-used-namespaces ( $root as node()? )  as xs:string* {&#xD;
let $prefix :=   (distinct-values($root/descendant-or-self::*/(.|@*)/substring-before(name(.), ':')) )&#xD;
let $namespaces :=   (distinct-values($root/descendant-or-self::*/(.|@*)/namespace-uri(.)) )&#xD;
return&#xD;
for $namespace at $pos in $namespaces&#xD;
    return &#xD;
        &#xD;
		let $ns := $prefix[$pos - 1]&#xD;
    			return&#xD;
            if ($namespace eq '') then&#xD;
                ()&#xD;
			else if ($namespace eq 'http://www.w3.org/XML/1998/namespace') then&#xD;
				()&#xD;
            else if ($ns) then 	&#xD;
       			concat('declare namespace ',$ns,'="',$namespace,'";')&#xD;
            else&#xD;
                concat('declare default element namespace "',$namespace,'";')&#xD;
} ;&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:validate($exp) as xs:string {&#xD;
$exp&#xD;
(:&#xD;
    nvdl:main("file:test/data/w3schema.xml file:test/data/schema-example.xml")&#xD;
:)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:serialize($xml,$options){&#xD;
	util:serialize($xml,$options)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:parse-string($string) as item()*{&#xD;
    util:parse($string)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:map($func, $seqA as item()*, $seqB as item()*) &#xD;
as item()* {&#xD;
	if(count($seqA) != count($seqB)) then ()&#xD;
	else&#xD;
    	for $a at $i in $seqA&#xD;
    	let $b := $seqB[$i]&#xD;
    	return&#xD;
        	u:call($func, $a, $b)&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
declare function u:filter($func, $seq as item()*) &#xD;
as item()* {&#xD;
	for $i in $seq&#xD;
	return&#xD;
		if(u:call($func, $i)) then&#xD;
			$i&#xD;
		else&#xD;
			()&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
(: test folding the step with a different function :)&#xD;
declare function u:printstep ($step,$meta,$value) {&#xD;
    u:call( $step, $value)&#xD;
};&#xD;
&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:strip-namespace($e as element()) as element() {&#xD;
  &#xD;
   element {QName((),local-name($e))} {&#xD;
    for $child in $e/(@*,node())&#xD;
    return&#xD;
      if ($child instance of element())&#xD;
      then&#xD;
        u:strip-namespace($child)&#xD;
      else&#xD;
        $child&#xD;
  }&#xD;
};&#xD;
&#xD;
(: -------------------------------------------------------------------------- :)&#xD;
&#xD;
declare function u:uniqueid($unique_id,$count){&#xD;
    concat($unique_id,'.',$count)&#xD;
};&#xD;
&#xD;
:)&#xD;
&#xD;
<EOF/></XQuery><!--Generated by xquerydoc: http://github.com/xquery/xquerydoc--><doc:date>2011-12-04T19:09:39.251+01:00</doc:date><doc:version><VersionDecl>(: ------------------------------------------------------------------------------------- &#xD;
 &#xD;
	util.xqm - contains most of the XQuery processor specific functions, including all&#xD;
	helper functions.&#xD;
	&#xD;
---------------------------------------------------------------------------------------- :)&#xD;
<TOKEN>xquery</TOKEN><TOKEN>version</TOKEN><StringLiteral>"3.0"</StringLiteral><TOKEN>encoding</TOKEN><StringLiteral>"UTF-8"</StringLiteral><Separator><TOKEN>;</TOKEN></Separator></VersionDecl></doc:version></doc:control><doc:module type="library"><doc:uri/></doc:module><doc:variables><doc:variable><doc:uri>NDEBUG</doc:uri></doc:variable></doc:variables><doc:functions><doc:function><doc:name>store</doc:name><doc:signature>($href as xs:string,$data as item())</doc:signature><doc:parameters><doc:parameter><doc:name>href</doc:name><doc:type> xs:string</doc:type></doc:parameter><doc:parameter><doc:name>data</doc:name><doc:type> item()</doc:type></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>parse</doc:name><doc:signature>($data as xs:string) as  item()</doc:signature><doc:parameters><doc:parameter><doc:name>data</doc:name><doc:type> xs:string</doc:type></doc:parameter></doc:parameters><doc:return><doc:type> item()</doc:type></doc:return></doc:function><doc:function><doc:name>serialize</doc:name><doc:signature>($xml) as  xs:string</doc:signature><doc:parameters><doc:parameter><doc:name>xml</doc:name></doc:parameter></doc:parameters><doc:return><doc:type> xs:string</doc:type></doc:return></doc:function><doc:function><doc:name>dirlist</doc:name><doc:signature>($path)</doc:signature><doc:parameters><doc:parameter><doc:name>path</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>evalXPATH</doc:name><doc:signature>($xpath, $xml)</doc:signature><doc:parameters><doc:parameter><doc:name>xpath</doc:name></doc:parameter><doc:parameter><doc:name>xml</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>transform</doc:name><doc:signature>($stylesheet,$xml)</doc:signature><doc:parameters><doc:parameter><doc:name>stylesheet</doc:name></doc:parameter><doc:parameter><doc:name>xml</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>xsltMatchPattern</doc:name><doc:signature>($xpath,$node)</doc:signature><doc:parameters><doc:parameter><doc:name>xpath</doc:name></doc:parameter><doc:parameter><doc:name/></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>outputResultElement</doc:name><doc:signature>($exp)</doc:signature><doc:parameters><doc:parameter><doc:name>exp</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>get-secondary</doc:name><doc:signature>($name as xs:string,$secondary as element(xproc:input)*) as  item()*</doc:signature><doc:parameters><doc:parameter><doc:name>name</doc:name><doc:type> xs:string</doc:type></doc:parameter><doc:parameter><doc:name>secondary</doc:name><doc:type occurrence="*"> element(xproc:input)</doc:type></doc:parameter></doc:parameters><doc:return><doc:type occurrence="*"> item()</doc:type></doc:return></doc:function><doc:function><doc:name>get-option</doc:name><doc:signature>($option-name as xs:string,$options as element(xproc:options),$primary) as  xs:string*</doc:signature><doc:parameters><doc:parameter><doc:name>option-name</doc:name><doc:type> xs:string</doc:type></doc:parameter><doc:parameter><doc:name>options</doc:name><doc:type> element(xproc:options)</doc:type></doc:parameter><doc:parameter><doc:name>primary</doc:name></doc:parameter></doc:parameters><doc:return><doc:type occurrence="*"> xs:string</doc:type></doc:return></doc:function><doc:function><doc:name>result-document</doc:name><doc:signature>($href as xs:string, $doc as item())</doc:signature><doc:parameters><doc:parameter><doc:name>href</doc:name><doc:type> xs:string</doc:type></doc:parameter><doc:parameter><doc:name>doc</doc:name><doc:type> item()</doc:type></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>dynamicError</doc:name><doc:signature>($error,$string)</doc:signature><doc:parameters><doc:parameter><doc:name>error</doc:name></doc:parameter><doc:parameter><doc:name>string</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>stepError</doc:name><doc:signature>($error,$string)</doc:signature><doc:parameters><doc:parameter><doc:name>error</doc:name></doc:parameter><doc:parameter><doc:name>string</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>binary-doc</doc:name><doc:signature>($uri)</doc:signature><doc:parameters><doc:parameter><doc:name>uri</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>binary-to-string</doc:name><doc:signature>($data)</doc:signature><doc:parameters><doc:parameter><doc:name>data</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>serialize</doc:name><doc:signature>($xml,$options)</doc:signature><doc:parameters><doc:parameter><doc:name>xml</doc:name></doc:parameter><doc:parameter><doc:name>options</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>trace</doc:name><doc:signature>($value as item()*, $what as xs:string)</doc:signature><doc:parameters><doc:parameter><doc:name>value</doc:name><doc:type occurrence="*"> item()</doc:type></doc:parameter><doc:parameter><doc:name>what</doc:name><doc:type> xs:string</doc:type></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>asserterror</doc:name><doc:signature>($errortype as xs:string, $booleanexp as item(), $why as xs:string)</doc:signature><doc:parameters><doc:parameter><doc:name>errortype</doc:name><doc:type> xs:string</doc:type></doc:parameter><doc:parameter><doc:name>booleanexp</doc:name><doc:type> item()</doc:type></doc:parameter><doc:parameter><doc:name>why</doc:name><doc:type> xs:string</doc:type></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>assert</doc:name><doc:signature>($booleanexp as item(), $why as xs:string)</doc:signature><doc:parameters><doc:parameter><doc:name>booleanexp</doc:name><doc:type> item()</doc:type></doc:parameter><doc:parameter><doc:name>why</doc:name><doc:type> xs:string</doc:type></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>assert</doc:name><doc:signature>($booleanexp as item(), $why as xs:string,$error)</doc:signature><doc:parameters><doc:parameter><doc:name>booleanexp</doc:name><doc:type> item()</doc:type></doc:parameter><doc:parameter><doc:name>why</doc:name><doc:type> xs:string</doc:type></doc:parameter><doc:parameter><doc:name>error</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>declarens</doc:name><doc:signature>($element)</doc:signature><doc:parameters><doc:parameter><doc:name/></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>declare-ns</doc:name><doc:signature>($namespaces)</doc:signature><doc:parameters><doc:parameter><doc:name>namespaces</doc:name></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>namespaces-in-use</doc:name><doc:signature>( $root as node()?)</doc:signature><doc:parameters><doc:parameter><doc:name>root</doc:name><doc:type occurrence="?"> node()</doc:type></doc:parameter></doc:parameters></doc:function><doc:function><doc:name>enum-ns</doc:name><doc:signature>($element)</doc:signature><doc:parameters><doc:parameter><doc:name/></doc:parameter></doc:parameters></doc:function></doc:functions></doc:xqdoc></textarea></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>