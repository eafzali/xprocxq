<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div id="main"><h1><span class="namespace">tparse</span>  library module </h1><div id="variables"><h3>Variables</h3></div><div id="functions"><h3>Functions</h3><div id="func_TEST_) tparse_loadModuleTest_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:loadModuleTest()</pre></h4></div><div id="func_TEST_) tparse_parseExplicitNames_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:parseExplicitNames()</pre></h4></div><div id="func_TEST_) tparse_parseExplicitNames1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:parseExplicitNames1()</pre></h4></div><div id="func_TEST_) tparse_parseExplicitNames2_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:parseExplicitNames2()</pre></h4></div><div id="func_TEST_) tparse_addParseNamespace_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:addParseNamespace()</pre></h4></div><div id="func_TEST_) tparse_addParseNamespace1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:addParseNamespace1()</pre></h4></div><div id="func_TEST_) tparse_testParseType1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testParseType1()</pre></h4></div><div id="func_TEST_) tparse_testParseType2_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testParseType2()</pre></h4></div><div id="func_TEST_) tparse_testParseType3_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testParseType3()</pre></h4></div><div id="func_TEST_) tparse_testParseType4_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testParseType4()</pre></h4></div><div id="func_TEST_) tparse_testParseType5_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testParseType5()</pre></h4></div><div id="func_TEST_) tparse_testParseType6_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testParseType6()</pre></h4></div><div id="func_TEST_) tparse_testExplicitName_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testExplicitName()</pre></h4></div><div id="func_TEST_) tparse_testExplicitName1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testExplicitName1()</pre></h4></div><div id="func_TEST_) tparse_testAST_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testAST()</pre></h4></div><div id="func_TEST_) tparse_testAST1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testAST1()</pre></h4></div><div id="func_TEST_) tparse_testExplicitBindings1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testExplicitBindings1()</pre></h4></div><div id="func_TEST_) tparse_testExplicitBindings2_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testExplicitBindings2()</pre></h4></div><div id="func_TEST_) tparse_testExplicitBindings3_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testExplicitBindings3()</pre></h4></div><div id="func_TEST_) tparse_testExplicitBindings4_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testExplicitBindings4()</pre></h4></div><div id="func_TEST_) tparse_testStepSort1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tparse:testStepSort1()</pre></h4></div></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">xquery version "3.0";

module namespace tparse ="tparse";

declare boundary-space strip;

declare namespace p="http://www.w3.org/ns/xproc";
declare namespace c="http://www.w3.org/ns/xproc-step";
declare namespace err="http://www.w3.org/ns/xproc-error";
declare namespace ext ="http://xproc.net/xproc/ext";
                    
import module namespace test = "http://www.marklogic.com/test"
    at "../lib/test.xqm";
              
import module namespace xproc = "http://xproc.net/xproc"
    at "../../xquery/xproc.xqm";

import module namespace parse = "http://xproc.net/xproc/parse"
    at "../../xquery/parse.xqm";
    
declare function (:TEST:) tparse:loadModuleTest() { 
  let $actual := &lt;test/&gt;
  return
    test:assertXMLEqual($actual,&lt;test/&gt;) 
};


declare function (:TEST:) tparse:parseExplicitNames() { 
  let $pipeline := fn:doc('data/test.xpl')
  let $result   := parse:explicit-type($pipeline)
  return
    $result
};

declare function (:TEST:) tparse:parseExplicitNames1() { 
  let $pipeline := fn:doc('data/submit-test-report.xpl')
  let $result   := parse:explicit-type($pipeline)
  return
    $result
};

declare function (:TEST:) tparse:parseExplicitNames2() { 
  let $pipeline := fn:doc('data/submit-test-report.xpl')
  let $result   := parse:explicit-type($pipeline)
  return
    $result
};

declare function (:TEST:) tparse:addParseNamespace() { 
  let $pipeline := fn:doc('data/test1.xpl')
  let $result   := parse:explicit-type($pipeline)
  return
    test:assertStringContain( fn:string-join(distinct-values($result/descendant-or-self::*/(.|@*)/namespace-uri(.)),' '),'http://xproc.net/xproc')
};

declare function (:TEST:) tparse:addParseNamespace1() { 
  let $pipeline := fn:doc('data/test1.xpl')
  let $result   := parse:explicit-type($pipeline)
  return
    test:assertStringContain( fn:string-join(distinct-values($result/descendant-or-self::*/(.|@*)/namespace-uri(.)),' '),'http://www.w3.org/ns/xproc')

};

declare function (:TEST:) tparse:testParseType1() { 
  let $result   := parse:type(&lt;p:identity/&gt;)
  return
    test:assertStringContain( $result, 'std')
};
declare function (:TEST:) tparse:testParseType2() { 
  let $result   := parse:type(&lt;p:exec/&gt;)
  return
    $result
};
declare function (:TEST:) tparse:testParseType3() { 
  let $result   := parse:type(&lt;ext:pre/&gt;)
  return
    test:assertStringContain( $result, 'ext')
};
declare function (:TEST:) tparse:testParseType4() { 
  let $result   := parse:type(&lt;p:input/&gt;)
  return
    test:assertStringContain( $result, 'comp')
};
declare function (:TEST:) tparse:testParseType5() { 
  let $result   := ''
  return
    test:assertStringContain( $result, '')
};
declare function (:TEST:) tparse:testParseType6() { 
  let $result   := parse:type(&lt;p:adsfadsfasdfadsf/&gt;)
  return
    (test:assertStringContain( $result, 'error'))
};

declare function (:TEST:) tparse:testExplicitName() { 
  let $pipeline := fn:doc('data/submit-test-report.xpl')
  let $result   := parse:explicit-type($pipeline)
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testExplicitName1() { 
  let $pipeline := fn:doc('data/test.xpl')
  let $result   := parse:explicit-name(parse:explicit-type($pipeline))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testAST() { 
  let $pipeline := fn:doc('data/test.xpl')
  let $result   := parse:AST(parse:explicit-name(parse:explicit-type($pipeline)))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testAST1() { 
  let $pipeline := fn:doc('data/submit-test-report.xpl')
  let $result   := parse:AST(parse:explicit-name(parse:explicit-type($pipeline)))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testExplicitBindings1() { 
  let $pipeline := fn:doc('data/test1.xpl')
  let $result   := parse:explicit-bindings( parse:AST(parse:explicit-name(parse:explicit-type($pipeline))))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testExplicitBindings2() { 
  let $pipeline := fn:doc('data/submit-test-report.xpl')
  let $result   := parse:explicit-bindings( parse:AST(parse:explicit-name(parse:explicit-type($pipeline))))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testExplicitBindings3() { 
  let $pipeline := fn:doc('data/test.xpl')
  let $result   := parse:explicit-bindings(parse:AST(parse:explicit-name(parse:explicit-type($pipeline))))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testExplicitBindings4() { 
  let $pipeline := fn:doc('data/test2.xpl')
  let $result   := parse:explicit-bindings( parse:AST(parse:explicit-name(parse:explicit-type($pipeline))))
  return 
    document{$result} 
};

declare function (:TEST:) tparse:testStepSort1() { 
  let $pipeline := fn:doc('data/test2.xpl')
  let $parse   := parse:explicit-bindings( parse:AST(parse:explicit-name(parse:explicit-type($pipeline))))
  let $result   := element p:declare-step {$parse/@*,
    namespace xproc {"http://xproc.net/xproc"},
    namespace ext {"http://xproc.net/xproc/ext"},
    namespace c {"http://www.w3.org/ns/xproc-step"},
    namespace err {"http://www.w3.org/ns/xproc-error"},
    namespace xxq-error {"http://xproc.net/xproc/error"},
    parse:pipeline-step-sort( $parse/*, () )
    }
  return 
    $result
};
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>