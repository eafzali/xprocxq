<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div id="main"><h1><span class="namespace">tstd</span>  library module </h1><div id="variables"><h3>Variables</h3></div><div id="functions"><h3>Functions</h3><div id="func_TEST_) tstd_loadModuleTest_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:loadModuleTest()</pre></h4></div><div id="func_TEST_) tstd_testIdentity_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testIdentity()</pre></h4></div><div id="func_TEST_) tstd_testCount_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testCount()</pre></h4></div><div id="func_TEST_) tstd_testCount2_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testCount2()</pre></h4></div><div id="func_TEST_) tstd_testCount3_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testCount3()</pre></h4></div><div id="func_TEST_) tstd_testCount4_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testCount4()</pre></h4></div><div id="func_TEST_) tstd_testError_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testError()</pre></h4></div><div id="func_TEST_) tstd_testFilter_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testFilter()</pre></h4></div><div id="func_TEST_) tstd_testDelete_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testDelete()</pre></h4></div><div id="func_TEST_) tstd_testDelete1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testDelete1()</pre></h4></div><div id="func_TEST_) tstd_testDelete2_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testDelete2()</pre></h4></div><div id="func_TEST_) tstd_testAddAttr_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testAddAttr()</pre></h4></div><div id="func_TEST_) tstd_testStringReplace_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testStringReplace()</pre></h4></div><div id="func_TEST_) tstd_testWrap_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testWrap()</pre></h4></div><div id="func_TEST_) tstd_testWrapSequence_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testWrapSequence()</pre></h4></div><div id="func_TEST_) tstd_testUnwrap_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testUnwrap()</pre></h4></div><div id="func_TEST_) tstd_testUnwrap1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testUnwrap1()</pre></h4></div><div id="func_TEST_) tstd_testRename_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testRename()</pre></h4></div><div id="func_TEST_) tstd_testRename1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testRename1()</pre></h4></div><div id="func_TEST_) tstd_testLabelElements_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testLabelElements()</pre></h4></div><div id="func_TEST_) tstd_testXSLT_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testXSLT()</pre></h4></div><div id="func_TEST_) tstd_testAddXMLBase_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testAddXMLBase()</pre></h4></div><div id="func_TEST_) tstd_testCompare_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testCompare()</pre></h4></div><div id="func_TEST_) tstd_testCompare1_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testCompare1()</pre></h4></div><div id="func_TEST_) tstd_testDirectoryList_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testDirectoryList()</pre></h4></div><div id="func_TEST_) tstd_testEscapeMarkup_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testEscapeMarkup()</pre></h4></div><div id="func_TEST_) tstd_testUnescapeMarkup_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testUnescapeMarkup()</pre></h4></div><div id="func_TEST_) tstd_testLoad_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testLoad()</pre></h4></div><div id="func_TEST_) tstd_testMakeAbsoluteUris_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testMakeAbsoluteUris()</pre></h4></div><div id="func_TEST_) tstd_testPack_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testPack()</pre></h4></div><div id="func_TEST_) tstd_testSink_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testSink()</pre></h4></div><div id="func_TEST_) tstd_testStore_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testStore()</pre></h4></div><div id="func_TEST_) tstd_testSetAttributes_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testSetAttributes()</pre></h4></div><div id="func_TEST_) tstd_testReplace_0"><h4><pre class="prettyprint lang-xq"><u>Function</u>: TEST:) tstd:testReplace()</pre></h4></div></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">xquery version "3.0";

module namespace tstd ="tstd";

(: declare namespaces :)
declare namespace xproc = "http://xproc.net/xproc";
declare namespace p="http://www.w3.org/ns/xproc";
declare namespace c="http://www.w3.org/ns/xproc-step";
declare namespace err="http://www.w3.org/ns/xproc-error";
declare namespace xsl="http://www.w3.org/1999/XSL/Transform";

import module namespace test = "http://www.marklogic.com/test"
    at "../lib/test.xqm";
              
import module namespace std = "http://xproc.net/xproc/std"
    at "../../xquery/std.xqm";
    
declare function (:TEST:) tstd:loadModuleTest() { 
  let $actual := &lt;test/&gt;
  return
    test:assertXMLEqual($actual,&lt;test/&gt;) 
};

declare function (:TEST:) tstd:testIdentity() { 
  let $actual := $std:identity(&lt;test/&gt;,(),(),())
  return
    $actual
};

declare function (:TEST:) tstd:testCount() { 
  let $actual := $std:count(&lt;test/&gt;,(),&lt;xproc:options&gt;&lt;p:with-option name='limit' select="'0'"/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testCount2() { 
  let $input  := (&lt;test/&gt;,&lt;test/&gt;,&lt;test/&gt;,&lt;test/&gt;)
  let $actual := $std:count($input,(),&lt;xproc:options&gt;&lt;p:with-option name='limit' select='5'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testCount3() { 
  let $input  := (&lt;test/&gt;,&lt;test/&gt;,&lt;test/&gt;,&lt;test/&gt;)
  let $actual := $std:count($input,(),&lt;xproc:options&gt;&lt;p:with-option name='limit' select='4'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testCount4() { 
  let $input  := (&lt;test/&gt;,&lt;test/&gt;,&lt;test/&gt;,&lt;test/&gt;)
  let $actual := $std:count($input,(),&lt;xproc:options&gt;&lt;p:with-option name='limit' select='2'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testError() { 
  let $input  := &lt;test/&gt;
  let $actual := $std:error($input,(),&lt;xproc:options&gt;&lt;p:with-option name='code' select='9999'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testFilter() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:filter($input,(),&lt;xproc:options&gt;&lt;p:with-option name='select' select='/c/a'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testDelete() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:delete($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='a'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testDelete1() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:delete($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testDelete2() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:delete($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='@*'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};


declare function (:TEST:) tstd:testAddAttr() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:add-attribute($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;p:with-option name='attribute-name' select='test'/&gt;&lt;p:with-option name='attribute-value' select='"test"'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};


declare function (:TEST:) tstd:testStringReplace() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:string-replace($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;p:with-option name='replace' select='aaaa'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};


declare function (:TEST:) tstd:testWrap() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:wrap($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;p:with-option name='wrapper' select='"aaaa"'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testWrapSequence() { 
  let $input  := (&lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;,&lt;a&gt;&lt;b&gt;aaa&lt;/b&gt;&lt;/a&gt;)
  let $actual := $std:wrap-sequence($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;p:with-option name='wrapper' select='"aaaa"'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testUnwrap() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:unwrap($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testUnwrap1() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:unwrap($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testRename() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:rename($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;p:with-option name='new-name' select='newname'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testRename1() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:rename($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='@id'/&gt;&lt;p:with-option name='new-name' select='newid'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testLabelElements() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $actual := $std:label-elements($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;p:with-option name='attribute' select='"xml:id"'/&gt;&lt;p:with-option name='replace' select='"true"'/&gt;&lt;p:with-option name='label' select='"somevalue"'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testXSLT() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $secondary := &lt;xproc:input step=""
             xproc:default-name=""
             port-type="input"
             href=""
             primary="false"
             select="/"
             port="stylesheet"
             func=""&gt;
&lt;xsl:stylesheet version="2.0"&gt;
&lt;xsl:template match="c"&gt;
    &lt;processed&gt;processed correctly&lt;/processed&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/xproc:input&gt;

let $actual := $std:xslt($input,$secondary,&lt;xproc:options&gt;
&lt;p:with-option name='initial-mode' select=''/&gt;
&lt;p:with-option name='template-name' select=''/&gt;
&lt;p:with-option name='output-base-uri' select=''/&gt;
&lt;p:with-option name='version' select='2.0'/&gt;&lt;/xproc:options&gt;,())
  return
    $actual
};

declare function (:TEST:) tstd:testAddXMLBase() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  return
    $std:add-xml-base($input,(),&lt;xproc:options&gt;&lt;p:with-option name='all' select='"false"'/&gt;&lt;p:with-option name='relative' select='"true"'/&gt;&lt;/xproc:options&gt;,())
};

declare function (:TEST:) tstd:testCompare() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $secondary := &lt;xproc:input step=""
             xproc:default-name=""
             port-type="input"
             href=""
             primary="false"
             select="/"
             port="alternate"
             func=""&gt;&lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;&lt;/xproc:input&gt;
  return
    $std:compare($input,$secondary,&lt;xproc:options&gt;&lt;p:with-option name='fail-if-not-equal' select='"false"'/&gt;&lt;/xproc:options&gt;,())
};


declare function (:TEST:) tstd:testCompare1() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $secondary := &lt;xproc:input step=""
             xproc:default-name=""
             port-type="input"
             href=""
             primary="false"
             select="/"
             port="alternate"
             func=""&gt;&lt;c&gt;aaa&lt;a id="1"&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;&lt;/xproc:input&gt;
  return
    $std:compare($input,$secondary,&lt;xproc:options&gt;&lt;p:with-option name='fail-if-not-equal' select='"false"'/&gt;&lt;/xproc:options&gt;,())
};

declare function (:TEST:) tstd:testDirectoryList() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  return
    $std:directory-list($input,(),&lt;xproc:options&gt;&lt;p:with-option name='path' select='"/Users/jfuller/Source/Webcomposite/xprocxq/src/test/tests/data"'/&gt;
&lt;p:with-option name='include-filter' select='""'/&gt;
&lt;p:with-option name='exclude-filter' select='""'/&gt;
&lt;/xproc:options&gt;,())
};


declare function (:TEST:) tstd:testEscapeMarkup() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  return
    $std:escape-markup($input,(),(),())
};


declare function (:TEST:) tstd:testUnescapeMarkup() { 
  let $input  := &lt;c&gt;&amp;lt;a id="1"&amp;gt;&amp;lt;b id="2"&amp;gt;test&amp;lt;/b&amp;gt;&amp;lt;b&amp;gt;alternate&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;&lt;/c&gt;
  return
    $std:unescape-markup($input,(),(),())
};

declare function (:TEST:) tstd:testLoad() { 
    $std:load((),(),&lt;xproc:options&gt;&lt;p:with-option name='href' select='"file:/Users/jfuller/Source/Webcomposite/xprocxq/src/test/tests/data/test1.xml"'/&gt;&lt;p:with-option name='dtd-validate' select='""'/&gt;
&lt;/xproc:options&gt;,())
};

declare function (:TEST:) tstd:testMakeAbsoluteUris() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  return
    $std:make-absolute-uris($input,(),&lt;xproc:options&gt;&lt;p:with-option name='match' select='c'/&gt;&lt;p:with-option name='base-uri' select='""'/&gt;&lt;/xproc:options&gt;,())
};


declare function (:TEST:) tstd:testPack() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $secondary := &lt;xproc:input step=""
             xproc:default-name=""
             port-type="input"
             href=""
             primary="false"
             select="/"
             port="alternate"
             func=""&gt;&lt;d&gt;pack me along&lt;/d&gt;&lt;/xproc:input&gt;
  return
    $std:pack($input,$secondary,&lt;xproc:options&gt;&lt;p:with-option name='wrapper' select='"packed"'/&gt;&lt;p:with-option name='wrapper-prefix' select='""'/&gt;&lt;p:with-option name='wrapper-namespace' select='""'/&gt;&lt;/xproc:options&gt;,())
};

declare function (:TEST:) tstd:testSink() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  return
    $std:sink($input,(),(),())
};

declare function (:TEST:) tstd:testStore() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  return
    $std:store($input,(),&lt;xproc:options&gt;&lt;p:with-option name='href' select='"/tmp/storetest.xml"'/&gt;&lt;/xproc:options&gt;,())
};

declare function (:TEST:) tstd:testSetAttributes() { 
  let $input  := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;b&gt;alternate&lt;/b&gt;&lt;/a&gt;&lt;/c&gt;
  let $secondary := &lt;xproc:input step=""
             xproc:default-name=""
             port-type="input"
             href=""
             primary="false"
             select="/"
             port="attributes"
             func=""&gt;&lt;d myattr="myattrval"/&gt;&lt;/xproc:input&gt;

  return
    $std:set-attributes($input,$secondary,&lt;xproc:options&gt;&lt;p:with-option name='match' select='c'/&gt;&lt;/xproc:options&gt;,())
};


declare function (:TEST:) tstd:testReplace() { 
  let $input     := &lt;c&gt;aaa&lt;a id="1"&gt;&lt;b id="2"&gt;test&lt;/b&gt;&lt;/a&gt;&lt;d&gt;&lt;r&gt;&lt;b/&gt;&lt;/r&gt;&lt;/d&gt;&lt;/c&gt;
  let $secondary := &lt;xproc:input step=""
             xproc:default-name=""
             port-type="input"
             href=""
             primary="false"
             select="/"
             port="replacement"
             func=""&gt;&lt;d myattr="myattrval"/&gt;&lt;/xproc:input&gt;
  return
    $std:replace($input,$secondary,&lt;xproc:options&gt;&lt;p:with-option name='match' select='b'/&gt;&lt;/xproc:options&gt;,())
};
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>